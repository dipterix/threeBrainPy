{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Welcome to <code>threebrainpy</code>","text":"<p><code>threebrainpy</code> is a Python package that visualizes MRI, CT, FreeSurfer surfaces, and iEEG electrodes in web browsers. See the parent projects via:</p> <ul> <li>RAVE (Reproducible Analysis and Visualization for iEEG)</li> <li>YAEL (Your Advanced Electrode Localizer)</li> </ul>"},{"location":"#project-layout","title":"Project layout","text":"<pre><code>mkdocs.yml    # The configuration file.\ndocs/\n    index.md  # The documentation homepage.\n    ...       # Other markdown pages, images and other files.\n</code></pre>"},{"location":"api-core-brain/","title":"<code>&lt;Class Brain&gt;</code>","text":"<p><code>Brain</code> is a high-level class that provides almost all the core features of <code>threebrainpy</code>.</p> <p>To import the <code>Brain</code> class, use the following command:</p> <pre><code>from threebrainpy.core import Brain\n</code></pre> <p>             Bases: <code>object</code></p> <p>Class definition for storing brain data and rendering information.</p> <p>Examples:</p> <p>This example loads <code>fsaverage</code> brain from FreeSurfer (if you have installed) and renders it.</p> <pre><code>&gt;&gt;&gt; import os\n&gt;&gt;&gt; from threebrainpy.core import Brain\n&gt;&gt;&gt; fs_home = os.environ.get(\"FREESURFER_HOME\", None)\n&gt;&gt;&gt; if fs_home is not None:\n&gt;&gt;&gt;     brain = Brain(\"fsaverage\", os.path.join(fs_home, \"subjects\", \"fsaverage\"))\n&gt;&gt;&gt;     print(brain)\n&gt;&gt;&gt;     brain.build()\n</code></pre> Source code in <code>threebrainpy/core/brain.py</code> <pre><code>class Brain(object):\n'''\n    Class definition for storing brain data and rendering information.\n    Examples:\n        This example loads `fsaverage` brain from FreeSurfer (if you have installed) and renders it.\n        &gt;&gt;&gt; import os\n        &gt;&gt;&gt; from threebrainpy.core import Brain\n        &gt;&gt;&gt; fs_home = os.environ.get(\"FREESURFER_HOME\", None)\n        &gt;&gt;&gt; if fs_home is not None:\n        &gt;&gt;&gt;     brain = Brain(\"fsaverage\", os.path.join(fs_home, \"subjects\", \"fsaverage\"))\n        &gt;&gt;&gt;     print(brain)\n        &gt;&gt;&gt;     brain.build()\n    '''\n    def _update_matrices(self, volume_files = [], update = 1):\n'''\n        Internal method to update voxel-to-ras and voxel-to-tkrRAS matrices.\n        Args:\n            volume_files: A list of volume files to be used to update the matrices.\n                Each volume file must be a path to a volume file (nii, nii.gz, mgz).\n            update: update policy, see below.\n                - 0: do not update, but will initialize if not exists;\n                - 1: update if there is a better one;\n                - 2: force update.\n        '''\n        if len(volume_files) == 0:\n            return None\n        for volume_file in volume_files:\n            if os.path.exists(volume_file):\n                vox2ras_needs_update = update &gt;= 2\n                vox2ras_tkr_needs_update = update &gt;= 2\n                # check if _vox2ras needs update\n                if not isinstance(self._vox2ras, Mat44):\n                    vox2ras_needs_update = True\n                if not isinstance(self._vox2ras_tkr, Mat44):\n                    vox2ras_tkr_needs_update = True\n                elif update == 1 and self._vox2ras_tkr.extra.get('source_format', None) is not \"mgz\" and volume_file.lower().endswith(\".mgz\"):\n                    vox2ras_tkr_needs_update = True\n                if vox2ras_needs_update or vox2ras_tkr_needs_update:\n                    volume = VolumeWrapper(volume_file)\n                    if vox2ras_needs_update:\n                        self._vox2ras = volume.vox2ras\n                    if vox2ras_tkr_needs_update:\n                        self._vox2ras_tkr = volume.vox2ras_tkr\n                # early stop\n                if not vox2ras_needs_update and not vox2ras_tkr_needs_update and update &lt; 2:\n                    # this means the matrices are all up-to-date and need no further update\n                    return None\n\n    def __init__(self, subject_code : str, path : str, work_dir : str | None = None):\n'''Constructor for Brain.\n        Args:\n            subject_code: The subject code of the brain.\n            path: The path to the FreeSurfer or FreeSurfer-like folder (with MRI stored at `mri` and surfaces at `surf`).\n            work_dir: The path to the working directory. If not specified, a temporary directory will be created.\n        '''\n        if not os.path.exists(path):\n            raise FileNotFoundError(f\"Brain path {path} not found.\")\n        if re.match(r\"^[a-zA-Z][a-zA-Z0-9_-]{0,}$\", subject_code) is None:\n            raise ValueError(f\"Invalid subject code: {subject_code}\")\n        self._path = os.path.abspath(path)\n        self._subject_code = subject_code\n        self._template_subject = \"N27\"\n        self._storage = temporary_directory(prefix = subject_code, dir = work_dir)\n        # set up geoms\n        self._groups = {}\n        self._geoms = {}\n        self._slices = {}\n        self._surfaces = {}\n        self._volumes = {}\n        self._electrode_contacts = {}\n        self._electrode_cmaps = {}\n        # set up global data, this must run prior to _update_matrices\n        self._initialize_global_data()\n        # Basic information \n        self._vox2ras = None\n        self._vox2ras_tkr = None\n        self._ras2mni_305 = None\n        # using CONSTANT.DEFAULT_SLICE_PREFIXIES and CONSTANT.DEFAULT_ATLAS_PREFIXIES to find the matrices\n        volume_prefixies = [*CONSTANTS.DEFAULT_SLICE_PREFIXIES, *CONSTANTS.DEFAULT_ATLAS_PREFIXIES]\n        mgz_files = [f\"{x}.mgz\" for x in volume_prefixies]\n        nii_gz_files = [f\"{x}.nii.gz\" for x in volume_prefixies]\n        nii_files = [f\"{x}.nii\" for x in volume_prefixies]\n        self._update_matrices(volume_files = [os.path.join(self.path_mri, x) for x in [*mgz_files, *nii_gz_files, *nii_files]])\n        # get ras to mni-305 matrix\n        xfm_file = os.path.join(self.path_mri, \"transforms\", \"talairach.xfm\")\n        try:\n            xfm = read_xfm(xfm_file)\n            self._ras2mni_305 = xfm['transform']\n        except:\n            self._ras2mni_305 = Mat44(space_from=\"ras\", space_to=\"mni305\")\n\n    def __del__(self):\n        self._storage.cleanup()\n    def __repr__(self):\n        return f\"Brain({self._subject_code} @ {self._path})\"\n    def __str__(self):\n        return f\"Brain({self._subject_code} @ {self._path})\"\n    @property\n    def subject_code(self):\n'''\n        Subject code string.\n        '''\n        return self._subject_code\n    # region &lt;paths&gt;\n    @property\n    def path(self):\n'''\n        The root path to the imaging files.\n        '''\n        return self._path\n    @property\n    def path_mri(self):\n'''\n        The path to the MRI and atlas files.\n        '''\n        return os.path.join(self._path, \"mri\")\n    @property\n    def path_surf(self):\n'''\n        The path to the surface mesh files.\n        '''\n        return os.path.join(self._path, \"surf\")\n    @property\n    def storage(self):\n'''\n        The path to a temporary directory for storing intermediate files and viewers.\n        '''\n        return self._storage\n    # endregion\n\n    # region &lt;transforms&gt;\n    @property\n    def vox2ras(self) -&gt; Mat44:\n'''\n        A `4x4` voxel (indexing) to T1 scanner RAS (right-anterior-superior coordinate) transform matrix.\n        '''\n        if isinstance(self._vox2ras, Mat44):\n            return self._vox2ras\n        m = Mat44(space_from=\"voxel\", space_to=\"ras\")\n        m.extra[\"missing\"] = True\n        return m\n    @property\n    def vox2ras_tkr(self) -&gt; Mat44:\n'''\n        A `4x4` voxel (indexing) to viewer (or FreeSurfer) tkrRAS (tk-registered right-anterior-superior coordinate) transform matrix.\n        '''\n        if isinstance(self._vox2ras_tkr, Mat44):\n            return self._vox2ras_tkr\n        m = Mat44(space_from=\"voxel\", space_to=\"ras_tkr\")\n        m.extra[\"missing\"] = True\n        return m\n    @property\n    def ras2ras_tkr(self) -&gt; Mat44:\n'''\n        A `4x4` T1 scanner RAS (right-anterior-superior coordinate) to viewer (or FreeSurfer tk-registered) tkrRAS transform matrix.\n        '''\n        return self.vox2ras_tkr * (~self.vox2ras)\n    @property\n    def ras2mni_305(self) -&gt; Mat44:\n'''\n        A `4x4` transform matrix from T1 scanner RAS (right-anterior-superior coordinate) to MNI305 template space using FreeSurfer affine transform (generated during `recon-all`).\n        '''\n        if isinstance(self._ras2mni_305, Mat44):\n            return self._ras2mni_305\n        m = Mat44(space_from=\"ras\", space_to=\"mni305\")\n        m.extra[\"missing\"] = True\n        return m\n    @property\n    def ras2mni_152(self) -&gt; Mat44:\n'''\n        A `4x4` transform matrix from T1 scanner RAS (right-anterior-superior coordinate) to MNI152 template space using FreeSurfer affine transform (generated during `recon-all`).\n        '''\n        return MNI305_TO_MNI152 * self.ras2mni_305\n    @property\n    def ras_tkr2mni_305(self) -&gt; Mat44:\n'''\n        A `4x4` transform matrix from tkrRAS to MNI305 template space using FreeSurfer affine transform (generated during `recon-all`).\n        '''\n        return self.ras2mni_305 * self.vox2ras * (~self.vox2ras_tkr)\n    @property\n    def ras_tkr2mni_152(self) -&gt; Mat44:\n'''\n        A `4x4` transform matrix from tkrRAS to MNI152 template space using FreeSurfer affine transform (generated during `recon-all`).\n        '''\n        return MNI305_TO_MNI152 * self.ras_tkr2mni_305\n    def get_transform(self, space_from : str, space_to : str) -&gt; Mat44:\n'''\n        Get transform matrix from `space_from` to `space_to`. \n        Args:\n            space_from: The space from which the transform matrix is defined.\n                choices are `voxel`, `ras`, `ras_tkr`, `mni305`, `mni152`.\n            space_to: The space to which the transform matrix is defined.\n                see `space_from` for choices.\n        Examples:\n            &gt;&gt;&gt; brain.get_transform(space_from = \"voxel\", space_to = \"ras_tkr\")\n            Mat44 (T1.voxel -&gt; T1.ras_tkr): \n            array([[  -1.,    0.,    0.,  128.],\n                [   0.,    0.,    1., -128.],\n                [   0.,   -1.,    0.,  128.],\n                [   0.,    0.,    0.,    1.]])\n        '''\n        if space_from not in CONSTANTS.SUPPORTED_SPACES:\n            raise ValueError(f\"Invalid space_from: {space_from}, supported spaces are: {CONSTANTS.SUPPORTED_SPACES}\")\n        if space_to not in CONSTANTS.SUPPORTED_SPACES:\n            raise ValueError(f\"Invalid space_to: {space_to}, supported spaces are: {CONSTANTS.SUPPORTED_SPACES}\")\n        if space_from == space_to:\n            return Mat44(space_from=space_from, space_to=space_to, modality_from=\"T1\", modality_to=\"T1\")\n        if space_from == \"ras\":\n            transform = Mat44(space_from=\"ras\", space_to=\"ras\", modality_from=\"T1\", modality_to=\"T1\")\n        elif space_from == \"ras_tkr\":\n            transform = deepcopy(~self.ras2ras_tkr)\n        elif space_from == \"mni305\":\n            transform = deepcopy(~self.ras2mni_305)\n        elif space_from == \"mni152\":\n            transform = deepcopy(~self.ras2mni_152)\n        else:\n            transform = deepcopy(self.vox2ras)\n        if space_to == \"ras\":\n            return transform\n        elif space_to == \"ras_tkr\":\n            return self.ras2ras_tkr * transform\n        elif space_to == \"mni305\":\n            return self.ras2mni_305 * transform\n        elif space_to == \"mni152\":\n            return self.ras2mni_152 * transform\n        else:\n            return (~self.vox2ras) * transform\n\n    def set_transform_space(self, transform : Mat44, space_from : str, space_to : str) -&gt; Mat44:\n'''\n        Returns a copy of `transform`, but with space transformed. \n        Args:\n            transform: The transform matrix of class `Mat44`. If `transform` is not specified, then the transform will be identity matrix.\n            space_from: The space from which the transform matrix will be defined.\n                choices are `voxel`, `ras`, `ras_tkr`, `mni305`, `mni152`.\n            space_to: The space to which the transform matrix will be defined.\n        Returns:\n            The new transform matrix with given spaces and inherited modalities.\n        Examples:\n            If you have a matrix that switch the column and row indexes in the voxel space,\n                what's the matrix in the ras space?\n            &gt;&gt;&gt; from threebrainpy.core import Mat44\n            &gt;&gt;&gt; idx_transform = Mat44([0,1,0,0,1,0,0,0,0,0,1,0], space_from = \"voxel\", space_to = \"voxel\")\n            &gt;&gt;&gt; idx_transform\n            Mat44 (T1.voxel -&gt; T1.voxel): \n            array([[0., 1., 0., 0.],\n                [1., 0., 0., 0.],\n                [0., 0., 1., 0.],\n                [0., 0., 0., 1.]])\n            &gt;&gt;&gt; # Applies idx_transform first then vox-to-ras\n            &gt;&gt;&gt; brain.set_transform_space(transform = idx_transform, space_from = \"voxel\", space_to = \"ras\")\n            Mat44 (T1.voxel -&gt; T1.ras): \n            array([[   0.        ,   -1.        ,    0.        ,  131.61447144],\n                [   0.        ,    0.        ,    1.        , -127.5       ],\n                [  -1.        ,    0.        ,    0.        ,  127.5       ],\n                [   0.        ,    0.        ,    0.        ,    1.        ]])\n            &gt;&gt;&gt; # To validate the transform\n            &gt;&gt;&gt; brain.vox2ras * idx_transform\n            Mat44 (T1.voxel -&gt; T1.ras): \n            array([[   0.        ,   -1.        ,    0.        ,  131.61447144],\n                [   0.        ,    0.        ,    1.        , -127.5       ],\n                [  -1.        ,    0.        ,    0.        ,  127.5       ],\n                [   0.        ,    0.        ,    0.        ,    1.        ]])\n        '''\n        if not isinstance(transform, Mat44):\n            raise TypeError(f\"Invalid transform matrix: {transform}\")\n        if space_from not in CONSTANTS.SUPPORTED_SPACES:\n            raise ValueError(f\"Invalid space_from: {space_from}, supported spaces are: {CONSTANTS.SUPPORTED_SPACES}\")\n        if space_to not in CONSTANTS.SUPPORTED_SPACES:\n            raise ValueError(f\"Invalid space_to: {space_to}, supported spaces are: {CONSTANTS.SUPPORTED_SPACES}\")\n        # check modalities\n        if transform.modality_from != \"T1\" and transform.space_from != space_from:\n            raise ValueError(f\"Invalid transform matrix: {transform}, modality_from must be 'T1' or space_from must be {space_from}.\")\n        if transform.modality_to != \"T1\" and transform.space_to != space_to:\n            raise ValueError(f\"Invalid transform matrix: {transform}, modality_to must be 'T1' or space_to must be {space_to}.\")\n        re = deepcopy(transform)\n        if transform.modality_from == \"T1\":\n            re = re * self.get_transform(space_to = transform.space_from, space_from = space_from)\n        if transform.modality_to == \"T1\":\n            re = self.get_transform(space_from = transform.space_to, space_to = space_to) * re\n        return re\n    # endregion\n\n    # region &lt;Group operations&gt;\n    def _initialize_global_data(self):\n        global_placeholder = BlankPlaceholder(brain = self)\n        self._globals = global_placeholder.group\n    def add_global_data(self, name : str, value : any | str, is_cache : bool = False, absolute_path : str = None):\n'''\n        Internal method to add global data to the brain.\n        Args:\n            name: The name of the global data.\n            value: If `is_cache=False`, the value of the global data, can be any JSON-serializable object.\n                If `is_cache=True`, the path to, or the file name of the cached JSON file.\n            is_cache: Whether the `value` is a cached JSON file.\n            absolute_path: The absolute path to the cached JSON file.\n        '''\n        self._globals.set_group_data(name = name, value = value, is_cache = is_cache, absolute_path = absolute_path)\n    def get_global_data(self, name):\n'''\n        Get global data from the brain instance.\n        Args:\n            name: The name of the global data.\n        Returns:\n            The value of the global data.\n        '''\n        return self._globals.get_group_data(name = name)\n    def add_group(self, name : str, exists_ok : bool = True) -&gt; GeomWrapper:\n'''\n        Internal method to add a geometry groups to the brain.\n        Args:\n            name: The name of the group.\n            exists_ok: Whether to overwrite the existing group if the group already exists.\n        Returns:\n            The group instance.\n        '''\n        group = self._groups.get(name, None)\n        if group is None:\n            group = GeomWrapper(self, name = name, position = [0,0,0], layers = [CONSTANTS.LAYER_USER_MAIN_CAMERA_0])\n            self._groups[name] = group\n        elif not exists_ok:\n            raise ValueError(f\"Group {name} already exists.\")\n        return group\n    def get_group(self, name : str) -&gt; GeomWrapper | None:\n'''\n        Get a geometry group from the brain.\n        Args:\n            name: The name of the group.\n        Returns:\n            The group instance or `None` if the group does not exist.\n        '''\n        return self._groups.get(name, None)\n    def has_group(self, name : str) -&gt; bool:\n'''\n        Check if the brain has a geometry group.\n        Args:\n            name: The name of the group.\n        Returns:\n            `True` if the group exists, `False` otherwise.\n        '''\n        return name in self._groups\n    def ensure_group(self, name : str, **kwargs : dict) -&gt; GeomWrapper:\n'''\n        Ensure that a geometry group exists, if not, create one.\n        Args:\n            name: The name of the group.\n            kwargs: Other arguments to be passed to `add_group`.\n        Returns:\n            The group instance.\n        '''\n        if self.has_group(name):\n            return self.get_group(name)\n        return self.add_group(name = name, exists_ok = True, **kwargs)\n    def set_group_data(self, name : str, value : any | str, is_cache : bool = False, absolute_path : str | None = None, auto_create : bool = True) -&gt; None:\n'''\n        Set group data to the brain so the JavaScript engine will have access to the data. \n            This method is a low-level function\n        Args:\n            name: The name of the group data.\n            value: If `is_cache=False`, the value of the group data, can be any JSON-serializable object.\n                If `is_cache=True`, the path to, or the file name of the cached JSON file.\n            is_cache: Whether the `value` is a cached JSON file.\n            absolute_path: The absolute path to the cached JSON file.\n            auto_create: Whether to create a group if the group does not exist.\n        '''\n        if auto_create:\n            self.ensure_group(name = name)\n        group = self.get_group(name)\n        if group is None:\n            raise ValueError(f\"Group {name} not found.\")\n        group.set_group_data(name = name, value = value, is_cache = is_cache, absolute_path = absolute_path)\n        return None\n    def get_global_data(self, name : str, force_reload : bool = False, ifnotfound : any | None = None) -&gt; any:\n'''\n        Get group data from the brain instance.\n        Args:\n            name: The name of the group data.\n            force_reload: Whether to force reload the group data.\n            ifnotfound: If the group data is not found, return this value.\n        Returns:\n            The value of the group data, or `ifnotfound`.\n        '''\n        group = self.get_group(name)\n        if group is None:\n            return ifnotfound\n        return group.get_group_data(name = name, force_reload = force_reload, ifnotfound = ifnotfound)\n    # endregion\n\n    # region &lt;Geometries&gt;\n    def get_geometry(self, name : str) -&gt; GeometryTemplate | None:\n'''\n        Get a geometry instance from the brain.\n        Args:\n            name: The name of the geometry template.\n        Returns:\n            The geometry instance or `None` if the geometry instance does not exist.\n        '''\n        return self._geoms.get(name, None)\n    def has_geometry(self, name : str) -&gt; bool:\n'''\n        Check if the brain has a geometry instance.\n        Args:\n            name: The name of the geometry template.\n        Returns:\n            `True` if the geometry instance exists, `False` otherwise.\n        '''\n        return name in self._geoms\n    # endregion\n\n    # region &lt;MRI slices&gt;\n    def add_slice(self, slice_prefix : str = \"brain.finalsurfs\", name : str = \"T1\"):\n'''\n        Add a (MRI) volume slice to the brain. The slices will be rendered in side canvas using datacube (JavaScript class).\n        Args:\n            slice_prefix: The prefix of the slice file in the `mri` folder. (default: \"brain.finalsurfs\")\n            name: The name of the slice, currently only \"T1\" is supported. (default: \"T1\")\n        Examples:\n            Adds `brain.finalsurfs.mgz` or `brain.finalsurfs.nii[.gz]` to the brain slices\n            &gt;&gt;&gt; brain.add_slice(slice_prefix = \"brain.finalsurfs\", name = \"T1\")\n        '''\n        # In geoms, the name needs to be appended with the subject code\n        # possible file names\n        slice_prefix = slice_prefix.lower()\n        candidates = [\n            f\"{slice_prefix}.mgz\",\n            f\"{slice_prefix}.nii.gz\",\n            f\"{slice_prefix}.nii\",\n        ]\n        slice_files = [x for x in os.listdir(self.path_mri) if x.lower() in candidates]\n        if len(slice_files) == 0:\n            return None\n        slice_file = slice_files[0]\n        slice_path = os.path.abspath(os.path.join(self.path_mri, slice_file))\n        slice = VolumeSlice(brain = self, name = f\"{name} ({self.subject_code})\", volume = slice_path)\n        self._slices[name] = slice\n        self._update_matrices(volume_files = [slice_path])\n        return slice\n    def get_slice(self, name : str) -&gt; VolumeSlice | None:\n'''\n        Get MRI slices from the brain.\n        Args:\n            name: The name of the slice.\n        Returns:\n            The slice instance or `None` if the slice does not exist.\n        '''\n        return self._slices.get(name, None)\n    def get_slices(self) -&gt; list[VolumeSlice]:\n'''\n        Get all MRI slices from the brain.\n        '''\n        return self._slices\n    def has_slice(self, name : str) -&gt; bool:\n'''\n        Check if the brain has MRI slices with given name.\n        '''\n        return name in self._slices\n    # endregion\n\n    # region &lt;Atlases/CT/3D voxels&gt;\n    def add_volume(self, volume_prefix : str, is_continuous : bool, name : str = None) -&gt; dict | None:\n'''\n        Add a (Atlas/CT/3D voxel) volume cube to the brain. The VolumeCube will be rendered in main canvas using datacube2 (JavaScript class).\n        Args:\n            volume_prefix: The prefix of the volume file in the `mri` folder. (e.g. \"aparc+aseg\", \"CT_raw\")\n            is_continuous: Whether the volume is continuous or discrete. \n                The color map for continuous and discrete values are set separately.\n                For continuous values, the volume will be rendered using RedFormat (single-channel shader). \n                    The color will be assgined according to the volume value (density).\n                For discrete values, the volume will be rendered using RGBAFormat (four-channel shader). \n                    The volume data will be used as the color index, and the color map will be set separately.\n                    The color index must be integer, and the color map must be a list of RGBA colors.\n            name: The name of the volume, default is to automatically derived from the volume_prefix. \n                Please set name to \"CT\" is the volume file is CT for localization\n        Examples:\n            Adds `aparc+aseg.mgz` or `aparc+aseg.nii[.gz]` to the brain volumes\n            &gt;&gt;&gt; brain.add_volume(volume_prefix = \"aparc+aseg\", is_continuous = False)\n        '''\n        # In geoms, the name needs to be appended with the subject code\n        # possible file names\n        volume_prefix = volume_prefix.lower()\n        if name is None:\n            name = re.sub(r\"[^a-zA-Z0-9_]\", \"_\", volume_prefix)\n        candidates = [\n            f\"{volume_prefix}.mgz\",\n            f\"{volume_prefix}.nii.gz\",\n            f\"{volume_prefix}.nii\",\n        ]\n        volume_files = [x for x in os.listdir(self.path_mri) if x.lower() in candidates]\n        if len(volume_files) == 0:\n            return None\n        volume_file = volume_files[0]\n        volume_path = os.path.abspath(os.path.join(self.path_mri, volume_file))\n        volume = VolumeWrapper(volume_path)\n        volume_cube = VolumeCube(brain = self, name = f\"Atlas - {name} ({self.subject_code})\", volume = volume,\n                                 color_format = \"RedFormat\" if is_continuous else \"RGBAFormat\")\n        self._update_matrices(volume_files = [volume_path])\n        self._volumes[name] = volume_cube\n        return volume_cube\n    # endregion\n\n    # region &lt;Surfaces&gt;\n    def _surface_morph_paths(self, hemesphere : str = \"both\", morph_types : tuple[str] | list[str] | str | None = None) -&gt; dict | None:\n        if hemesphere.lower()[0] not in ['l', 'r', 'b']:\n            raise ValueError(f\"Invalid hemesphere: {hemesphere}\")\n        hemesphere = hemesphere.lower()[0]\n        if hemesphere == \"b\":\n            hemesphere = [\"lh\", \"rh\"]\n        else:\n            hemesphere = [f\"{ hemesphere }h\"]\n        if morph_types is None:\n            morph_types = CONSTANTS.SURFACE_BASE_TEXTURE_TYPES\n        elif isinstance(morph_types, str):\n            morph_types = [morph_types]\n        for morph_type in morph_types:\n            not_found = False\n            re = dict([(h, os.path.join(self.path_surf, f\"{h}.{morph_type}\")) for h in hemesphere])\n            for h, morph_path in re.items():\n                if not os.path.exists(morph_path):\n                    not_found = True\n                    break\n            if not not_found:\n                return re\n        return None\n\n    def add_surfaces(self, surface_type : str, hemesphere : str = \"both\") -&gt; dict | None:\n'''\n        Add a surface to the brain. The surface will be rendered in main canvas using surface (JavaScript class).\n        Args:\n            surface_type: The type of the surface, e.g. \"pial\", \"white\", \"inflated\", \"sphere\" (see `surf/` folder, usually `[lr]h.&lt;surface_type&gt;`).\n            hemesphere: The hemesphere of the surface, can be \"l\", \"r\", \"b\" (both). (default: \"both\")\n        Returns:\n            A dictionary of surface instances if exist, with keys being the hemesphere.\n        Examples:\n            Adds `lh.pial` and `rh.pial` to the brain surfaces\n            &gt;&gt;&gt; brain.add_surfaces(surface_type = \"pial\", hemesphere = \"both\")\n        '''\n        hemesphere_prefix = hemesphere.lower()[0]\n        if hemesphere_prefix == \"b\":\n            hemesphere_prefix = [\"lh\", \"rh\"]\n        elif hemesphere_prefix == \"l\":\n            hemesphere_prefix = [\"lh\"]\n        elif hemesphere_prefix == \"r\":\n            hemesphere_prefix = [\"rh\"]\n        else:\n            raise ValueError(f\"Invalid hemesphere: {hemesphere}\")\n        surface_type0 = surface_type\n        surface_type = surface_type.lower()\n        if surface_type in (\"pial\", \"pial.t1\",):\n            # Newer freesurfer versions use \"pial.T1\" as the surface type, while older versions use \"pial\"\n            surface_type = [\"pial\", \"pial.t1\"]\n            surface_type0 = \"pial\"\n        # construct possible file names\n        file_names_lower = []\n        for h in hemesphere_prefix:\n            for s in surface_type:\n                file_names_lower.append(f\"{h}.{s}\")\n        # search for the file\n        if not os.path.exists(self.path_surf):\n            return None\n        if not os.path.isdir(self.path_surf):\n            return None\n        surface_files = [x for x in os.listdir(self.path_surf) if x.lower() in file_names_lower]\n        if len(surface_files) == 0:\n            return None\n        surface_dict = self._surfaces.get(surface_type0, None)\n        if not isinstance(surface_dict, dict):\n            surface_dict = {}\n            self._surfaces[surface_type0] = surface_dict\n        # check base vertex colors\n        base_vertex_colors = self._surface_morph_paths()\n        for surface_filename in surface_files:\n            surface_file = os.path.join(self.path_surf, surface_filename)\n            surface = CorticalSurface(brain = self, surface_type = surface_type0, surface_file = surface_file, hemesphere = surface_filename[0])\n            surface_dict[ surface.hemesphere ] = surface\n            if isinstance(base_vertex_colors, dict):\n                surface.group.set_group_data(\n                    name = f\"{surface.hemesphere}_primary_vertex_color\", \n                    value = base_vertex_colors[surface.hemesphere], is_cache = True)\n        return surface_dict\n    def get_surfaces(self, surface_type : str) -&gt; dict | None:\n'''\n        Get surfaces from the brain.\n        Args:\n            surface_type: The type of the surface, e.g. \"pial\", \"white\", \"inflated\", \"sphere\" (see `surf/` folder, usually `[lr]h.&lt;surface_type&gt;`).\n        Returns:\n            A dictionary of surface instances if exist, with keys being the hemesphere.\n        '''\n        return self._surfaces.get(surface_type, None)\n    def has_surface_type(self, surface_type : str) -&gt; bool:\n'''\n        Check if the brain has surfaces with given type.\n        Args:\n            surface_type: The type of the surface, e.g. \"pial\", \"white\", \"inflated\", \"sphere\" (see `surf/` folder, usually `[lr]h.&lt;surface_type&gt;`).\n        '''\n        return surface_type in self._surfaces\n    # endregion\n\n    # region &lt;Electrode contacts&gt;\n    def add_electrode_contact(\n            self, number : int, label : str, \n            position : Vec3 | list | None = None, \n            is_surface : bool = False, \n            radius : float | None = None,\n            mni_position : Vec3 | list | None = None, \n            sphere_position : Vec3 | list | None = None,\n            **kwargs : dict) -&gt; ElectrodeSphere:\n'''\n        Add an electrode contact to the brain. The electrode contact will be rendered in main canvas using sphere (JavaScript class).\n        Args:\n            number: The integer number of the electrode contact, starting from 1.\n            label: The label of the electrode contact.\n            position: The position of the electrode contact in the native space of the brain, or a `Vec3` instance with given spaces.\n            is_surface: Whether the electrode contact is a surface electrode.\n            radius: The radius of the electrode contact, default is 2.0 for surface electrodes and 1.0 for depth electrodes.\n            mni_position: The position of the electrode contact in MNI space, overrides the default affine MNI calculation; \n                often used if you have advanced/more accurate MNI estimation\n            sphere_position: The position of the electrode contact in the sphere space; surface electrodes only.\n            kwargs: Other arguments to be passed to `ElectrodeSphere`.\n        Returns:\n            The electrode contact instance.\n        Examples:\n            Adds an electrode contact to the brain\n            &gt;&gt;&gt; e1 = brain.add_electrode_contact(number = 1, label = \"LA1\", position = [35,10,10], is_surface = False)\n            &gt;&gt;&gt; e1.get_position(\"ras\")\n            Vec3(35.0, 10.0, 10.0) [ras]\n            &gt;&gt;&gt; e2 = brain.add_electrode_contact(number = 2, label = \"LA2\", position = Vec3([5,10,10], space = \"voxel\"), is_surface = False)\n            &gt;&gt;&gt; # Automatically transform position to RAS space\n            &gt;&gt;&gt; e2.get_position(\"ras\")\n            Vec3(126.61447143554688, -117.5, 117.5) [ras]\n        '''\n        is_surface = True if is_surface else False\n        if radius is None:\n            radius = 2.0 if is_surface else 1.0\n        contact = ElectrodeSphere(\n            brain = self,\n            number = number, \n            label = label, \n            position = position, \n            radius = radius,\n            is_surface = is_surface,\n            **kwargs)\n        if mni_position is not None:\n            contact.set_mni_position(mni_position)\n        if sphere_position is not None:\n            contact.set_sphere_position(sphere_position)\n        self._electrode_contacts[ contact.number ] = contact\n        return contact\n    def set_electrode_keyframe(self, number : int, value : np.ndarray | list[float] | list[int] | list[str] | float | int | str, \n                               time : float | list[float] | tuple(float) | np.ndarray | None = None, \n                               name : str = \"value\") -&gt; SimpleKeyframe | None:\n'''\n        Low-level method to set electrode contacts keyframe (values).\n        Args:\n            number: The integer number of the electrode contact, starting from 1.\n            value: The value of the keyframe, can be numerical or characters.\n            time: The time (second) of the keyframe, default is `None` which means 0.\n            name: The name of the keyframe, default is \"value\".\n        Returns:\n            The keyframe created\n        '''\n        contact = self._electrode_contacts.get(int(number), None)\n        if contact is None:\n            return None\n        return contact.set_keyframe(value = value, time = time, name = name)\n    def get_electrode_contact(self, number : int) -&gt; ElectrodeSphere | None:\n'''\n        Get an electrode contact from the brain.\n        Args:\n            number: The integer number of the electrode contact, starting from 1.\n        Returns:\n            The electrode contact instance or `None` if the electrode contact does not exist.\n        '''\n        return self._electrode_contacts.get(int(number), None)\n    @property\n    def electrode_contacts(self) -&gt; dict[int, ElectrodeSphere]:\n'''\n        Get all electrode contacts from the brain.\n        '''\n        return self._electrode_contacts\n    def clean_electrodes(self):\n'''\n        Remove all electrode contacts from the brain.\n        '''\n        contact_names = [contact.name for _, contact in self._electrode_contacts.items()]\n        for contact_name in contact_names:\n            self._geoms.pop(contact_name, None)\n            self._electrode_contacts.pop(contact_name, None)\n    def add_electrodes(self, table : str | DataFrame, space : str | None = 'ras') -&gt; int:\n'''\n        Add electrodes to the brain.\n        Args:\n            table: A pandas table containing the electrode information, or the path to the table. (See 'Details:')\n            space: The space of the electrode coordinates, default is \"ras\".\n        Returns:\n            The number of electrodes added.\n\n        Details:\n            The table (or table file) must contains at least the following columns (**case-sensitive**):\n\n            * `Electrode` (int, mandatory): electrode contact number, starting from 1\n\n            * `Label` (str, mandatory): electrode label string, must not be empty string\n\n            * `x`, `y`, `z` (float): the coordinates of the electrode contact in the space specified by `space`.\n\n                If `space` is not specified, then the coordinates are assumed to be in the T1 space (\"ras\").\n\n                &gt; If x=y=z=0, then the electrode will be hidden. (This is the default behavior of R package threeBrain)\n\n                If `x`, `y`, `z` is not specified, then the following columns will be used in order:\n\n                * `Coord_x`, `Coord_y`, `Coord_z`: electrode coordinates in tkrRAS space (FreeSurfer space)\n                * `T1R`, `T1A`, `T1S`: electrode coordinates in T1 RAS space (scanner space)\n                * `MNI305_x`, `MNI305_y`, `MNI305_z`: electrode coordinates in MNI305 space\n                * `MNI152_x`, `MNI152_y`, `MNI152_z`: electrode coordinates in MNI152 space\n\n                The order will be Coord_* &gt; T1* &gt; MNI305_* &gt; MNI152_* to be consistent with R package threeBrain.\n\n                &gt; xyz in native (subject brain) space and MNI space can co-exist in the same table. In this case,\n                &gt; the native space coordinates will be used to show the electrodes in the native brain,\n                &gt; and the MNI space coordinates will be used to show the electrodes on the template brain.\n\n            The following columns are optional:\n\n            * `Radius` (float): the radius of the electrode contact, default is 1.0 for sEEG and 2.0 for ECoG\n            * `Hemisphere` (str, [\"auto\", \"left\", \"right\"]): the hemisphere of the electrode contact, default is \"auto\"\n                If \"auto\", then the hemisphere will be determined by the `FSLabel` column.\n            * `Sphere_x`, `Sphere_y`, `Sphere_z` (float): the coordinates of the electrode contact in the sphere space (surface electrodes only)\n            * `SurfaceElectrode` (bool): whether the electrode is a surface electrode, default is False\n            * `FSLabel` (str): the FreeSurfer label of the electrode contact.\n        '''\n        if space is None:\n            space = \"ras\"\n        elif not space in CONSTANTS.SUPPORTED_SPACES:\n            raise ValueError(f\"Invalid space: {space}, supported spaces are: {CONSTANTS.SUPPORTED_SPACES}\")\n        # table = \"/Users/dipterix/Dropbox (PennNeurosurgery)/RAVE/Samples/data/demo/PAV006/rave/meta/electrodes.csv\"\n        if isinstance(table, str):\n            import pandas as pd\n            table = pd.read_csv(table, sep = \",\")\n        # assume table is pandas since we don't want to import pandas here\n        nrows = table.shape[0]\n        valid_length = lambda l: np.isfinite(l) and l &gt; 0 and l &lt; 500\n        for ii in range(nrows):\n            row = table.iloc[ii].to_dict()\n            electrode = row[\"Electrode\"]\n            label = row.get(\"Label\", \"\").strip()\n            if label == \"\":\n                label = f\"NoLabel{ electrode }\"\n            x = row.get(\"x\", None)\n            y = row.get(\"y\", None)\n            z = row.get(\"z\", None)\n            xyz = Vec3(x, y, z, space=space)\n            tkr_x = row.get(\"Coord_x\", None)\n            tkr_y = row.get(\"Coord_y\", None)\n            tkr_z = row.get(\"Coord_z\", None)\n            tkr_ras = Vec3(tkr_x, tkr_y, tkr_z, space=\"ras_tkr\")\n            t1_x = row.get(\"T1R\", None)\n            t1_y = row.get(\"T1A\", None)\n            t1_z = row.get(\"T1S\", None)\n            ras = Vec3(t1_x, t1_y, t1_z, space=\"ras\")\n            mni305_x = row.get(\"MNI305_x\", None)\n            mni305_y = row.get(\"MNI305_y\", None)\n            mni305_z = row.get(\"MNI305_z\", None)\n            mni305 = Vec3(mni305_x, mni305_y, mni305_z, space=\"mni305\")\n            mni152_x = row.get(\"MNI152_x\", None)\n            mni152_y = row.get(\"MNI152_y\", None)\n            mni152_z = row.get(\"MNI152_z\", None)\n            mni152 = Vec3(mni152_x, mni152_y, mni152_z, space=\"mni152\")\n            mni_position = mni305\n            if valid_length( xyz.length() ):\n                position = xyz\n            elif valid_length( tkr_ras.length() ):\n                position = tkr_ras\n            elif valid_length( ras.length() ):\n                position = ras\n            elif valid_length( mni305.length() ):\n                position = mni305\n            elif valid_length( mni152.length() ):\n                position = mni152\n            else:\n                position = None\n            if not valid_length( mni_position.length() ):\n                mni_position = mni152\n            if not valid_length( mni_position.length() ):\n                mni_position = None\n            sphere_x = row.get(\"Sphere_x\", None)\n            sphere_y = row.get(\"Sphere_y\", None)\n            sphere_z = row.get(\"Sphere_z\", None)\n            sphere_position = Vec3(sphere_x, sphere_y, sphere_z, space=\"sphere\")\n            if not valid_length( sphere_position.length() ):\n                sphere_position = None\n            radius = row.get(\"Radius\", None)\n            is_surface = row.get(\"SurfaceElectrode\", False)\n            fs_label = row.get(\"FSLabel\", \"Unknown\")\n            hemisphere = row.get(\"Hemisphere\", \"auto\").lower()\n            if len(hemisphere) == 0 or hemisphere[0] not in [\"l\", \"r\"]:\n                hemisphere = \"auto\"\n                # also guess the hemisphere from the FSLabel\n                if re.match(r\"^(left|(ctx|wm)[_-]lh)\", fs_label, re.IGNORECASE):\n                    hemisphere = \"left\"\n                elif re.match(r\"^(right|(ctx|wm)[_-]rh)\", fs_label, re.IGNORECASE):\n                    hemisphere = \"right\"\n            else:\n                if hemisphere[0] == \"l\":\n                    hemisphere = \"left\"\n                elif hemisphere[0] == \"r\":\n                    hemisphere = \"right\"\n            self.add_electrode_contact(\n                number = electrode, label = label, position = position,\n                is_surface = is_surface, radius = radius,\n                mni_position = mni_position, sphere_position = sphere_position,\n                hemisphere = hemisphere)\n        return len(self._electrode_contacts)\n    def set_electrode_value(self, number : int, name : str, value : list[float] | list[str] | dict | float | str, \n                            time : list[float] | float | None = None) -&gt; SimpleKeyframe | None:\n'''\n        Set value to a electrode contact.\n        Args:\n            number: The electrode contact number.\n            name: The data name of the value.\n            value: The value to set, can be a list of values or a single value.\n            time: The time of the value, can be a list of times (in seconds) or a single time.\n        Returns: \n            The keyframe object or None if the electrode contact is not found.\n        '''\n        contact = self._electrode_contacts.get(int(number), None)\n        if contact is None:\n            return None\n        return contact.set_keyframe(value = value, time = time, name = name)\n    def set_electrode_values(self, table : str | DataFrame):\n'''\n        Set single or multiple values to multiple electrode contacts.\n        Args: \n            table: A pandas or a path to a csv file. The see 'Details' for table contents\n        Details:\n            The table (or table file) contains the following columns (**case-sensitive**):\n\n            * `Electrode` (mandatory): The electrode contact number, starting from 1\n            * `Subject` (optional): The subject code of the value, default is the current subject code\n            * `Time` (optional): The numeric time of the value, in seconds\n            * All other columns: The the column names are the data names of the values, can \n                be combinations of letters `[a-zA-Z]`, numbers `[0-9]`, dots `.`, and underscores `_`\n        Examples:\n            The minimal table contains only the electrode contact number and the value:\n\n            | Electrode | brain.response |\n            |-----------|----------------|\n            | 1         | 0.1            |\n            | 2         | 0.2            |\n            | 3         | 0.3            |\n\n\n            Here's an example of the table with two variables `brain.response` and `classifier`, \n            and two electrodes `1` and `2`. The time range is `0~1` seconds.\n\n            | Electrode | Time | brain.response | classifier |\n            |-----------|------|----------------|------------|\n            | 1         | 0    | 0.1            | A          |\n            | 1         | 1    | 0.2            | A          |\n            | 2         | 0    | 0.3            | A          |\n            | 2         | 1    | 0.4            | B          |\n        '''\n        if isinstance(table, str):\n            # table = \"/Users/dipterix/rave_data/data_dir/demo/DemoSubject/rave/meta/electrodes.csv\"\n            import pandas as pd\n            table = pd.read_csv(table, sep = \",\")\n        # assume table is pandas since we don't want to import pandas here\n        if \"Electrode\" not in table.columns:\n            raise LookupError(f\"Invalid table, must contain column 'Electrode'.\")\n        time = table.get(\"Time\", None)\n        subjects = table.get(\"Subject\", None)\n        electrodes = table[\"Electrode\"]\n        electrode_numbers = electrodes.unique()\n        var_names = [x for x in table.columns if x not in [\"Electrode\", \"Time\"]]\n        if subjects is not None:\n            subjects = subjects == self.subject_code\n        else:\n            subjects = True\n        for electrode in electrode_numbers:\n            sel = (electrodes == electrode) &amp; subjects\n            if sel.size &gt; 0 and sel.sum() &gt; 0:\n                for name in var_names:\n                    keyframe = self.set_electrode_value(\n                        number = electrode, name = name, value = table[name][sel].tolist(), \n                        time = None if time is None else time[sel])\n                    if isinstance(keyframe, SimpleKeyframe):\n                        # get colormap\n                        colormap = self._electrode_cmaps.get(name, None)\n                        if colormap is None:\n                            colormap = ElectrodeColormap(keyframe_name = keyframe, value_type = \"continuous\" if keyframe.is_continuous else \"discrete\")\n                            self._electrode_cmaps[name] = colormap\n                        colormap.update_from_keyframe( keyframe = keyframe )\n        return \n    def get_electrode_colormap(self, name : str) -&gt; ElectrodeColormap | None:\n'''\n        Get the colormap of an electrode contact.\n        Args:\n            name: The name of the electrode keyframe (which is also the color-map name).\n        Returns:\n            The colormap instance or `None` if the colormap does not exist.\n        '''\n        return self._electrode_cmaps.get(name, None)\n    # endregion\n\n    def to_dict(self) -&gt; dict:\n'''\n        Convert the brain to a dict.\n        Returns: \n            A dict containing the brain data.\n        '''\n        # global_data needs to be rebuilt\n        self._globals.set_group_data(\n            name = \"subject_data\", \n            is_cache = False,\n            value = {\n                'subject_code' : self.subject_code,\n                'Norig': self.vox2ras.mat.tolist(),\n                'Torig': self.vox2ras_tkr.mat.tolist(),\n                'xfm': self.ras2mni_305.mat.tolist(),\n                # FreeSurfer RAS to MNI305, should be ras_tkr2mni_305, but for compatibility, vox2vox_MNI305\n                'vox2vox_MNI305': self.ras_tkr2mni_305.mat.tolist(),\n                # -(self$Norig %*% solve( self$Torig ) %*% c(0,0,0,1))[1:3]\n                'volume_types' : list(self._slices.keys()),\n                'atlas_types' : [], # self._atlases.keys()\n            })\n        geom_list = []\n        group_list = []\n        for _, geom in self._geoms.items():\n            geom_list.append(geom)\n        for _, group in self._groups.items():\n            group_list.append(group)\n        # The config file should contain groups and geoms\n        return {\n            'subject_code': self.subject_code,\n            'storage': self.storage.name,\n            'path': self.path,\n            \"settings\": {},\n            \"groups\": group_list,\n            \"geoms\": geom_list,\n        }\n    def build(self, path : str | None = None, dry_run : bool = False):\n'''\n        Build the brain cache. If `path` is not specified, the cache will be built under the temporary directory.\n        Args:\n            path: The path to build the cache; default is using the `self._storage` path.\n            dry_run: If True, the cache will not be built, instead, the build process will be printed to the console.\n        '''\n        config = self.to_dict()\n        # Needs to generate a global data dict to include all global data for compatibility\n        build_global = BlankPlaceholder(brain = self, is_global = True)\n        build_group = GeomWrapper(brain = self, name = build_global.group_name)\n        config['geoms'].insert(0, build_global)\n        config['groups'].insert(0, build_group)\n        build_group.set_group_data(name = '__global_data__.subject_codes', value = [self.subject_code], is_cache = False)\n\n        # Construct colormaps\n        cmaps = {}\n        for _, colormap in self._electrode_cmaps.items():\n            cmap_data = colormap.to_dict()\n            if isinstance(cmap_data, dict):\n                cmaps[ colormap.name ] = cmap_data\n        default_cmap = list(cmaps.keys())[0] if len(cmaps) &gt; 0 else None\n\n        # Hard-code for now\n        build_group.set_group_data(\n            name = '__global_data__.SurfaceColorLUT', \n            value = template_path(f\"lib/threeBrain_data-0/{ build_group.cache_name }/ContinuousSample.json\"),\n            is_cache = True\n        )\n        build_group.set_group_data(\n            name = '__global_data__.VolumeColorLUT', \n            value = template_path(f\"lib/threeBrain_data-0/{ build_group.cache_name }/FreeSurferColorLUT.json\"),\n            is_cache = True\n        )\n        build_group.set_group_data(\n            name = '__global_data__.FSColorLUT', \n            value = template_path(f\"lib/threeBrain_data-0/{ build_group.cache_name }/FSColorLUT.json\"),\n            is_cache = True\n        )\n\n        settings = config['settings']\n        settings['title'] = \"\"\n        settings['side_camera'] = True\n        settings['side_canvas_zoom'] = 1\n        settings['side_canvas_width'] = 250\n        settings['side_canvas_shift'] = [0, 0]\n        settings['color_maps'] = cmaps\n        settings['default_colormap'] = default_cmap\n        settings['hide_controls'] = False\n        settings['control_center'] = [0, 0, 0]\n        settings['camera_pos'] = [500, 0, 0]\n        settings['font_magnification'] = 1\n        settings['start_zoom'] = 1\n        settings['show_legend'] = True\n        settings['render_timestamp'] = True\n        settings['control_presets'] = [\n            \"subject2\", \"surface_type2\", \"hemisphere_material\", \"surface_color\", \"map_template\",\n            \"electrodes\", \"voxel\", \"animation\", \"display_highlights\"\n        ]\n        settings['cache_folder'] = \"lib/threebrain_data-0/\"\n        settings['lib_path'] = \"lib/\"\n        settings['default_controllers'] = []\n        settings['debug'] = True\n        settings['background'] = \"#FFFFFF\"\n        settings['token'] = None\n        settings['show_inactive_electrodes'] = True\n        settings['side_display'] = True\n        settings['control_display'] = True\n        settings['custom_javascript'] = None\n\n        # write files\n        # dry_run = False\n        # path=os.path.join(ensure_default_temporary_directory(), \"test\")\n        if path is None:\n            path = self._storage.name\n        init_skeleton(path, dry_run = dry_run)\n        # for each group data, check if is_cache, if so, copy the file to the cache folder\n        for group in config['groups']:\n            group.build(path = path, dry_run = dry_run)\n        # construct config.json\n        if dry_run:\n            print(\"Writing config.json...\")\n        else:\n            import json\n            s = json.dumps({\n                \"groups\": config['groups'],\n                \"geoms\": config['geoms'],\n            }, cls = GeomEncoder)\n            with open(os.path.join(path, \"lib\", \"threebrain_data-0\", \"config.json\"), \"w\") as f:\n                f.write(s)\n\n        # construct index.html\n        if dry_run:\n            print(\"Writing index.html...\")\n        else:\n            with open(template_path(\"index.html\"), \"r\") as f:\n                index_content = \"\\n\".join(f.readlines())\n            index_content = index_content.replace(\"WIDGET_ID\", \"threebrainpy-viewer\")\n            widget_data = json.dumps({\n                'x' : {\n                    'data_filename' : 'config.json',\n                    \"force_render\":True,\n                    'settings' : settings,\n                },\n                \"evals\":[],\"jsHooks\":[]\n            }, cls = GeomEncoder)\n            index_content = index_content.replace(\"WIDGET_DATA\", widget_data)\n            index_path = os.path.join(path, \"index.html\")\n            with open(index_path, \"w\") as f:\n                f.write(index_content)\n</code></pre>"},{"location":"api-core-brain/#threebrainpy.core.brain.Brain.electrode_contacts","title":"<code>electrode_contacts: dict[int, ElectrodeSphere]</code>  <code>property</code>","text":"<p>Get all electrode contacts from the brain.</p>"},{"location":"api-core-brain/#threebrainpy.core.brain.Brain.path","title":"<code>path</code>  <code>property</code>","text":"<p>The root path to the imaging files.</p>"},{"location":"api-core-brain/#threebrainpy.core.brain.Brain.path_mri","title":"<code>path_mri</code>  <code>property</code>","text":"<p>The path to the MRI and atlas files.</p>"},{"location":"api-core-brain/#threebrainpy.core.brain.Brain.path_surf","title":"<code>path_surf</code>  <code>property</code>","text":"<p>The path to the surface mesh files.</p>"},{"location":"api-core-brain/#threebrainpy.core.brain.Brain.ras2mni_152","title":"<code>ras2mni_152: Mat44</code>  <code>property</code>","text":"<p>A <code>4x4</code> transform matrix from T1 scanner RAS (right-anterior-superior coordinate) to MNI152 template space using FreeSurfer affine transform (generated during <code>recon-all</code>).</p>"},{"location":"api-core-brain/#threebrainpy.core.brain.Brain.ras2mni_305","title":"<code>ras2mni_305: Mat44</code>  <code>property</code>","text":"<p>A <code>4x4</code> transform matrix from T1 scanner RAS (right-anterior-superior coordinate) to MNI305 template space using FreeSurfer affine transform (generated during <code>recon-all</code>).</p>"},{"location":"api-core-brain/#threebrainpy.core.brain.Brain.ras2ras_tkr","title":"<code>ras2ras_tkr: Mat44</code>  <code>property</code>","text":"<p>A <code>4x4</code> T1 scanner RAS (right-anterior-superior coordinate) to viewer (or FreeSurfer tk-registered) tkrRAS transform matrix.</p>"},{"location":"api-core-brain/#threebrainpy.core.brain.Brain.ras_tkr2mni_152","title":"<code>ras_tkr2mni_152: Mat44</code>  <code>property</code>","text":"<p>A <code>4x4</code> transform matrix from tkrRAS to MNI152 template space using FreeSurfer affine transform (generated during <code>recon-all</code>).</p>"},{"location":"api-core-brain/#threebrainpy.core.brain.Brain.ras_tkr2mni_305","title":"<code>ras_tkr2mni_305: Mat44</code>  <code>property</code>","text":"<p>A <code>4x4</code> transform matrix from tkrRAS to MNI305 template space using FreeSurfer affine transform (generated during <code>recon-all</code>).</p>"},{"location":"api-core-brain/#threebrainpy.core.brain.Brain.storage","title":"<code>storage</code>  <code>property</code>","text":"<p>The path to a temporary directory for storing intermediate files and viewers.</p>"},{"location":"api-core-brain/#threebrainpy.core.brain.Brain.subject_code","title":"<code>subject_code</code>  <code>property</code>","text":"<p>Subject code string.</p>"},{"location":"api-core-brain/#threebrainpy.core.brain.Brain.vox2ras","title":"<code>vox2ras: Mat44</code>  <code>property</code>","text":"<p>A <code>4x4</code> voxel (indexing) to T1 scanner RAS (right-anterior-superior coordinate) transform matrix.</p>"},{"location":"api-core-brain/#threebrainpy.core.brain.Brain.vox2ras_tkr","title":"<code>vox2ras_tkr: Mat44</code>  <code>property</code>","text":"<p>A <code>4x4</code> voxel (indexing) to viewer (or FreeSurfer) tkrRAS (tk-registered right-anterior-superior coordinate) transform matrix.</p>"},{"location":"api-core-brain/#threebrainpy.core.brain.Brain.__init__","title":"<code>__init__(subject_code, path, work_dir=None)</code>","text":"<p>Constructor for Brain.</p> <p>Parameters:</p> Name Type Description Default <code>subject_code</code> <code>str</code> <p>The subject code of the brain.</p> required <code>path</code> <code>str</code> <p>The path to the FreeSurfer or FreeSurfer-like folder (with MRI stored at <code>mri</code> and surfaces at <code>surf</code>).</p> required <code>work_dir</code> <code>str | None</code> <p>The path to the working directory. If not specified, a temporary directory will be created.</p> <code>None</code> Source code in <code>threebrainpy/core/brain.py</code> <pre><code>def __init__(self, subject_code : str, path : str, work_dir : str | None = None):\n'''Constructor for Brain.\n    Args:\n        subject_code: The subject code of the brain.\n        path: The path to the FreeSurfer or FreeSurfer-like folder (with MRI stored at `mri` and surfaces at `surf`).\n        work_dir: The path to the working directory. If not specified, a temporary directory will be created.\n    '''\n    if not os.path.exists(path):\n        raise FileNotFoundError(f\"Brain path {path} not found.\")\n    if re.match(r\"^[a-zA-Z][a-zA-Z0-9_-]{0,}$\", subject_code) is None:\n        raise ValueError(f\"Invalid subject code: {subject_code}\")\n    self._path = os.path.abspath(path)\n    self._subject_code = subject_code\n    self._template_subject = \"N27\"\n    self._storage = temporary_directory(prefix = subject_code, dir = work_dir)\n    # set up geoms\n    self._groups = {}\n    self._geoms = {}\n    self._slices = {}\n    self._surfaces = {}\n    self._volumes = {}\n    self._electrode_contacts = {}\n    self._electrode_cmaps = {}\n    # set up global data, this must run prior to _update_matrices\n    self._initialize_global_data()\n    # Basic information \n    self._vox2ras = None\n    self._vox2ras_tkr = None\n    self._ras2mni_305 = None\n    # using CONSTANT.DEFAULT_SLICE_PREFIXIES and CONSTANT.DEFAULT_ATLAS_PREFIXIES to find the matrices\n    volume_prefixies = [*CONSTANTS.DEFAULT_SLICE_PREFIXIES, *CONSTANTS.DEFAULT_ATLAS_PREFIXIES]\n    mgz_files = [f\"{x}.mgz\" for x in volume_prefixies]\n    nii_gz_files = [f\"{x}.nii.gz\" for x in volume_prefixies]\n    nii_files = [f\"{x}.nii\" for x in volume_prefixies]\n    self._update_matrices(volume_files = [os.path.join(self.path_mri, x) for x in [*mgz_files, *nii_gz_files, *nii_files]])\n    # get ras to mni-305 matrix\n    xfm_file = os.path.join(self.path_mri, \"transforms\", \"talairach.xfm\")\n    try:\n        xfm = read_xfm(xfm_file)\n        self._ras2mni_305 = xfm['transform']\n    except:\n        self._ras2mni_305 = Mat44(space_from=\"ras\", space_to=\"mni305\")\n</code></pre>"},{"location":"api-core-brain/#threebrainpy.core.brain.Brain.add_electrode_contact","title":"<code>add_electrode_contact(number, label, position=None, is_surface=False, radius=None, mni_position=None, sphere_position=None, **kwargs)</code>","text":"<p>Add an electrode contact to the brain. The electrode contact will be rendered in main canvas using sphere (JavaScript class).</p> <p>Parameters:</p> Name Type Description Default <code>number</code> <code>int</code> <p>The integer number of the electrode contact, starting from 1.</p> required <code>label</code> <code>str</code> <p>The label of the electrode contact.</p> required <code>position</code> <code>Vec3 | list | None</code> <p>The position of the electrode contact in the native space of the brain, or a <code>Vec3</code> instance with given spaces.</p> <code>None</code> <code>is_surface</code> <code>bool</code> <p>Whether the electrode contact is a surface electrode.</p> <code>False</code> <code>radius</code> <code>float | None</code> <p>The radius of the electrode contact, default is 2.0 for surface electrodes and 1.0 for depth electrodes.</p> <code>None</code> <code>mni_position</code> <code>Vec3 | list | None</code> <p>The position of the electrode contact in MNI space, overrides the default affine MNI calculation;  often used if you have advanced/more accurate MNI estimation</p> <code>None</code> <code>sphere_position</code> <code>Vec3 | list | None</code> <p>The position of the electrode contact in the sphere space; surface electrodes only.</p> <code>None</code> <code>kwargs</code> <code>dict</code> <p>Other arguments to be passed to <code>ElectrodeSphere</code>.</p> <code>{}</code> <p>Returns:</p> Type Description <code>ElectrodeSphere</code> <p>The electrode contact instance.</p> <p>Examples:</p> <p>Adds an electrode contact to the brain</p> <pre><code>&gt;&gt;&gt; e1 = brain.add_electrode_contact(number = 1, label = \"LA1\", position = [35,10,10], is_surface = False)\n&gt;&gt;&gt; e1.get_position(\"ras\")\nVec3(35.0, 10.0, 10.0) [ras]\n&gt;&gt;&gt; e2 = brain.add_electrode_contact(number = 2, label = \"LA2\", position = Vec3([5,10,10], space = \"voxel\"), is_surface = False)\n&gt;&gt;&gt; # Automatically transform position to RAS space\n&gt;&gt;&gt; e2.get_position(\"ras\")\nVec3(126.61447143554688, -117.5, 117.5) [ras]\n</code></pre> Source code in <code>threebrainpy/core/brain.py</code> <pre><code>def add_electrode_contact(\n        self, number : int, label : str, \n        position : Vec3 | list | None = None, \n        is_surface : bool = False, \n        radius : float | None = None,\n        mni_position : Vec3 | list | None = None, \n        sphere_position : Vec3 | list | None = None,\n        **kwargs : dict) -&gt; ElectrodeSphere:\n'''\n    Add an electrode contact to the brain. The electrode contact will be rendered in main canvas using sphere (JavaScript class).\n    Args:\n        number: The integer number of the electrode contact, starting from 1.\n        label: The label of the electrode contact.\n        position: The position of the electrode contact in the native space of the brain, or a `Vec3` instance with given spaces.\n        is_surface: Whether the electrode contact is a surface electrode.\n        radius: The radius of the electrode contact, default is 2.0 for surface electrodes and 1.0 for depth electrodes.\n        mni_position: The position of the electrode contact in MNI space, overrides the default affine MNI calculation; \n            often used if you have advanced/more accurate MNI estimation\n        sphere_position: The position of the electrode contact in the sphere space; surface electrodes only.\n        kwargs: Other arguments to be passed to `ElectrodeSphere`.\n    Returns:\n        The electrode contact instance.\n    Examples:\n        Adds an electrode contact to the brain\n        &gt;&gt;&gt; e1 = brain.add_electrode_contact(number = 1, label = \"LA1\", position = [35,10,10], is_surface = False)\n        &gt;&gt;&gt; e1.get_position(\"ras\")\n        Vec3(35.0, 10.0, 10.0) [ras]\n        &gt;&gt;&gt; e2 = brain.add_electrode_contact(number = 2, label = \"LA2\", position = Vec3([5,10,10], space = \"voxel\"), is_surface = False)\n        &gt;&gt;&gt; # Automatically transform position to RAS space\n        &gt;&gt;&gt; e2.get_position(\"ras\")\n        Vec3(126.61447143554688, -117.5, 117.5) [ras]\n    '''\n    is_surface = True if is_surface else False\n    if radius is None:\n        radius = 2.0 if is_surface else 1.0\n    contact = ElectrodeSphere(\n        brain = self,\n        number = number, \n        label = label, \n        position = position, \n        radius = radius,\n        is_surface = is_surface,\n        **kwargs)\n    if mni_position is not None:\n        contact.set_mni_position(mni_position)\n    if sphere_position is not None:\n        contact.set_sphere_position(sphere_position)\n    self._electrode_contacts[ contact.number ] = contact\n    return contact\n</code></pre>"},{"location":"api-core-brain/#threebrainpy.core.brain.Brain.add_electrodes","title":"<code>add_electrodes(table, space='ras')</code>","text":"<p>Add electrodes to the brain.</p> <p>Parameters:</p> Name Type Description Default <code>table</code> <code>str | DataFrame</code> <p>A pandas table containing the electrode information, or the path to the table. (See 'Details:')</p> required <code>space</code> <code>str | None</code> <p>The space of the electrode coordinates, default is \"ras\".</p> <code>'ras'</code> <p>Returns:</p> Type Description <code>int</code> <p>The number of electrodes added.</p> Details <p>The table (or table file) must contains at least the following columns (case-sensitive):</p> <ul> <li> <p><code>Electrode</code> (int, mandatory): electrode contact number, starting from 1</p> </li> <li> <p><code>Label</code> (str, mandatory): electrode label string, must not be empty string</p> </li> <li> <p><code>x</code>, <code>y</code>, <code>z</code> (float): the coordinates of the electrode contact in the space specified by <code>space</code>.</p> <p>If <code>space</code> is not specified, then the coordinates are assumed to be in the T1 space (\"ras\").</p> <p>If x=y=z=0, then the electrode will be hidden. (This is the default behavior of R package threeBrain)</p> <p>If <code>x</code>, <code>y</code>, <code>z</code> is not specified, then the following columns will be used in order:</p> <ul> <li><code>Coord_x</code>, <code>Coord_y</code>, <code>Coord_z</code>: electrode coordinates in tkrRAS space (FreeSurfer space)</li> <li><code>T1R</code>, <code>T1A</code>, <code>T1S</code>: electrode coordinates in T1 RAS space (scanner space)</li> <li><code>MNI305_x</code>, <code>MNI305_y</code>, <code>MNI305_z</code>: electrode coordinates in MNI305 space</li> <li><code>MNI152_x</code>, <code>MNI152_y</code>, <code>MNI152_z</code>: electrode coordinates in MNI152 space</li> </ul> <p>The order will be Coord_ &gt; T1 &gt; MNI305_ &gt; MNI152_ to be consistent with R package threeBrain.</p> <p>xyz in native (subject brain) space and MNI space can co-exist in the same table. In this case, the native space coordinates will be used to show the electrodes in the native brain, and the MNI space coordinates will be used to show the electrodes on the template brain.</p> </li> </ul> <p>The following columns are optional:</p> <ul> <li><code>Radius</code> (float): the radius of the electrode contact, default is 1.0 for sEEG and 2.0 for ECoG</li> <li><code>Hemisphere</code> (str, [\"auto\", \"left\", \"right\"]): the hemisphere of the electrode contact, default is \"auto\"     If \"auto\", then the hemisphere will be determined by the <code>FSLabel</code> column.</li> <li><code>Sphere_x</code>, <code>Sphere_y</code>, <code>Sphere_z</code> (float): the coordinates of the electrode contact in the sphere space (surface electrodes only)</li> <li><code>SurfaceElectrode</code> (bool): whether the electrode is a surface electrode, default is False</li> <li><code>FSLabel</code> (str): the FreeSurfer label of the electrode contact.</li> </ul> Source code in <code>threebrainpy/core/brain.py</code> <pre><code>def add_electrodes(self, table : str | DataFrame, space : str | None = 'ras') -&gt; int:\n'''\n    Add electrodes to the brain.\n    Args:\n        table: A pandas table containing the electrode information, or the path to the table. (See 'Details:')\n        space: The space of the electrode coordinates, default is \"ras\".\n    Returns:\n        The number of electrodes added.\n\n    Details:\n        The table (or table file) must contains at least the following columns (**case-sensitive**):\n\n        * `Electrode` (int, mandatory): electrode contact number, starting from 1\n\n        * `Label` (str, mandatory): electrode label string, must not be empty string\n\n        * `x`, `y`, `z` (float): the coordinates of the electrode contact in the space specified by `space`.\n\n            If `space` is not specified, then the coordinates are assumed to be in the T1 space (\"ras\").\n\n            &gt; If x=y=z=0, then the electrode will be hidden. (This is the default behavior of R package threeBrain)\n\n            If `x`, `y`, `z` is not specified, then the following columns will be used in order:\n\n            * `Coord_x`, `Coord_y`, `Coord_z`: electrode coordinates in tkrRAS space (FreeSurfer space)\n            * `T1R`, `T1A`, `T1S`: electrode coordinates in T1 RAS space (scanner space)\n            * `MNI305_x`, `MNI305_y`, `MNI305_z`: electrode coordinates in MNI305 space\n            * `MNI152_x`, `MNI152_y`, `MNI152_z`: electrode coordinates in MNI152 space\n\n            The order will be Coord_* &gt; T1* &gt; MNI305_* &gt; MNI152_* to be consistent with R package threeBrain.\n\n            &gt; xyz in native (subject brain) space and MNI space can co-exist in the same table. In this case,\n            &gt; the native space coordinates will be used to show the electrodes in the native brain,\n            &gt; and the MNI space coordinates will be used to show the electrodes on the template brain.\n\n        The following columns are optional:\n\n        * `Radius` (float): the radius of the electrode contact, default is 1.0 for sEEG and 2.0 for ECoG\n        * `Hemisphere` (str, [\"auto\", \"left\", \"right\"]): the hemisphere of the electrode contact, default is \"auto\"\n            If \"auto\", then the hemisphere will be determined by the `FSLabel` column.\n        * `Sphere_x`, `Sphere_y`, `Sphere_z` (float): the coordinates of the electrode contact in the sphere space (surface electrodes only)\n        * `SurfaceElectrode` (bool): whether the electrode is a surface electrode, default is False\n        * `FSLabel` (str): the FreeSurfer label of the electrode contact.\n    '''\n    if space is None:\n        space = \"ras\"\n    elif not space in CONSTANTS.SUPPORTED_SPACES:\n        raise ValueError(f\"Invalid space: {space}, supported spaces are: {CONSTANTS.SUPPORTED_SPACES}\")\n    # table = \"/Users/dipterix/Dropbox (PennNeurosurgery)/RAVE/Samples/data/demo/PAV006/rave/meta/electrodes.csv\"\n    if isinstance(table, str):\n        import pandas as pd\n        table = pd.read_csv(table, sep = \",\")\n    # assume table is pandas since we don't want to import pandas here\n    nrows = table.shape[0]\n    valid_length = lambda l: np.isfinite(l) and l &gt; 0 and l &lt; 500\n    for ii in range(nrows):\n        row = table.iloc[ii].to_dict()\n        electrode = row[\"Electrode\"]\n        label = row.get(\"Label\", \"\").strip()\n        if label == \"\":\n            label = f\"NoLabel{ electrode }\"\n        x = row.get(\"x\", None)\n        y = row.get(\"y\", None)\n        z = row.get(\"z\", None)\n        xyz = Vec3(x, y, z, space=space)\n        tkr_x = row.get(\"Coord_x\", None)\n        tkr_y = row.get(\"Coord_y\", None)\n        tkr_z = row.get(\"Coord_z\", None)\n        tkr_ras = Vec3(tkr_x, tkr_y, tkr_z, space=\"ras_tkr\")\n        t1_x = row.get(\"T1R\", None)\n        t1_y = row.get(\"T1A\", None)\n        t1_z = row.get(\"T1S\", None)\n        ras = Vec3(t1_x, t1_y, t1_z, space=\"ras\")\n        mni305_x = row.get(\"MNI305_x\", None)\n        mni305_y = row.get(\"MNI305_y\", None)\n        mni305_z = row.get(\"MNI305_z\", None)\n        mni305 = Vec3(mni305_x, mni305_y, mni305_z, space=\"mni305\")\n        mni152_x = row.get(\"MNI152_x\", None)\n        mni152_y = row.get(\"MNI152_y\", None)\n        mni152_z = row.get(\"MNI152_z\", None)\n        mni152 = Vec3(mni152_x, mni152_y, mni152_z, space=\"mni152\")\n        mni_position = mni305\n        if valid_length( xyz.length() ):\n            position = xyz\n        elif valid_length( tkr_ras.length() ):\n            position = tkr_ras\n        elif valid_length( ras.length() ):\n            position = ras\n        elif valid_length( mni305.length() ):\n            position = mni305\n        elif valid_length( mni152.length() ):\n            position = mni152\n        else:\n            position = None\n        if not valid_length( mni_position.length() ):\n            mni_position = mni152\n        if not valid_length( mni_position.length() ):\n            mni_position = None\n        sphere_x = row.get(\"Sphere_x\", None)\n        sphere_y = row.get(\"Sphere_y\", None)\n        sphere_z = row.get(\"Sphere_z\", None)\n        sphere_position = Vec3(sphere_x, sphere_y, sphere_z, space=\"sphere\")\n        if not valid_length( sphere_position.length() ):\n            sphere_position = None\n        radius = row.get(\"Radius\", None)\n        is_surface = row.get(\"SurfaceElectrode\", False)\n        fs_label = row.get(\"FSLabel\", \"Unknown\")\n        hemisphere = row.get(\"Hemisphere\", \"auto\").lower()\n        if len(hemisphere) == 0 or hemisphere[0] not in [\"l\", \"r\"]:\n            hemisphere = \"auto\"\n            # also guess the hemisphere from the FSLabel\n            if re.match(r\"^(left|(ctx|wm)[_-]lh)\", fs_label, re.IGNORECASE):\n                hemisphere = \"left\"\n            elif re.match(r\"^(right|(ctx|wm)[_-]rh)\", fs_label, re.IGNORECASE):\n                hemisphere = \"right\"\n        else:\n            if hemisphere[0] == \"l\":\n                hemisphere = \"left\"\n            elif hemisphere[0] == \"r\":\n                hemisphere = \"right\"\n        self.add_electrode_contact(\n            number = electrode, label = label, position = position,\n            is_surface = is_surface, radius = radius,\n            mni_position = mni_position, sphere_position = sphere_position,\n            hemisphere = hemisphere)\n    return len(self._electrode_contacts)\n</code></pre>"},{"location":"api-core-brain/#threebrainpy.core.brain.Brain.add_global_data","title":"<code>add_global_data(name, value, is_cache=False, absolute_path=None)</code>","text":"<p>Internal method to add global data to the brain.</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>The name of the global data.</p> required <code>value</code> <code>any | str</code> <p>If <code>is_cache=False</code>, the value of the global data, can be any JSON-serializable object. If <code>is_cache=True</code>, the path to, or the file name of the cached JSON file.</p> required <code>is_cache</code> <code>bool</code> <p>Whether the <code>value</code> is a cached JSON file.</p> <code>False</code> <code>absolute_path</code> <code>str</code> <p>The absolute path to the cached JSON file.</p> <code>None</code> Source code in <code>threebrainpy/core/brain.py</code> <pre><code>def add_global_data(self, name : str, value : any | str, is_cache : bool = False, absolute_path : str = None):\n'''\n    Internal method to add global data to the brain.\n    Args:\n        name: The name of the global data.\n        value: If `is_cache=False`, the value of the global data, can be any JSON-serializable object.\n            If `is_cache=True`, the path to, or the file name of the cached JSON file.\n        is_cache: Whether the `value` is a cached JSON file.\n        absolute_path: The absolute path to the cached JSON file.\n    '''\n    self._globals.set_group_data(name = name, value = value, is_cache = is_cache, absolute_path = absolute_path)\n</code></pre>"},{"location":"api-core-brain/#threebrainpy.core.brain.Brain.add_group","title":"<code>add_group(name, exists_ok=True)</code>","text":"<p>Internal method to add a geometry groups to the brain.</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>The name of the group.</p> required <code>exists_ok</code> <code>bool</code> <p>Whether to overwrite the existing group if the group already exists.</p> <code>True</code> <p>Returns:</p> Type Description <code>GeomWrapper</code> <p>The group instance.</p> Source code in <code>threebrainpy/core/brain.py</code> <pre><code>def add_group(self, name : str, exists_ok : bool = True) -&gt; GeomWrapper:\n'''\n    Internal method to add a geometry groups to the brain.\n    Args:\n        name: The name of the group.\n        exists_ok: Whether to overwrite the existing group if the group already exists.\n    Returns:\n        The group instance.\n    '''\n    group = self._groups.get(name, None)\n    if group is None:\n        group = GeomWrapper(self, name = name, position = [0,0,0], layers = [CONSTANTS.LAYER_USER_MAIN_CAMERA_0])\n        self._groups[name] = group\n    elif not exists_ok:\n        raise ValueError(f\"Group {name} already exists.\")\n    return group\n</code></pre>"},{"location":"api-core-brain/#threebrainpy.core.brain.Brain.add_slice","title":"<code>add_slice(slice_prefix='brain.finalsurfs', name='T1')</code>","text":"<p>Add a (MRI) volume slice to the brain. The slices will be rendered in side canvas using datacube (JavaScript class).</p> <p>Parameters:</p> Name Type Description Default <code>slice_prefix</code> <code>str</code> <p>The prefix of the slice file in the <code>mri</code> folder. (default: \"brain.finalsurfs\")</p> <code>'brain.finalsurfs'</code> <code>name</code> <code>str</code> <p>The name of the slice, currently only \"T1\" is supported. (default: \"T1\")</p> <code>'T1'</code> <p>Examples:</p> <p>Adds <code>brain.finalsurfs.mgz</code> or <code>brain.finalsurfs.nii[.gz]</code> to the brain slices</p> <pre><code>&gt;&gt;&gt; brain.add_slice(slice_prefix = \"brain.finalsurfs\", name = \"T1\")\n</code></pre> Source code in <code>threebrainpy/core/brain.py</code> <pre><code>def add_slice(self, slice_prefix : str = \"brain.finalsurfs\", name : str = \"T1\"):\n'''\n    Add a (MRI) volume slice to the brain. The slices will be rendered in side canvas using datacube (JavaScript class).\n    Args:\n        slice_prefix: The prefix of the slice file in the `mri` folder. (default: \"brain.finalsurfs\")\n        name: The name of the slice, currently only \"T1\" is supported. (default: \"T1\")\n    Examples:\n        Adds `brain.finalsurfs.mgz` or `brain.finalsurfs.nii[.gz]` to the brain slices\n        &gt;&gt;&gt; brain.add_slice(slice_prefix = \"brain.finalsurfs\", name = \"T1\")\n    '''\n    # In geoms, the name needs to be appended with the subject code\n    # possible file names\n    slice_prefix = slice_prefix.lower()\n    candidates = [\n        f\"{slice_prefix}.mgz\",\n        f\"{slice_prefix}.nii.gz\",\n        f\"{slice_prefix}.nii\",\n    ]\n    slice_files = [x for x in os.listdir(self.path_mri) if x.lower() in candidates]\n    if len(slice_files) == 0:\n        return None\n    slice_file = slice_files[0]\n    slice_path = os.path.abspath(os.path.join(self.path_mri, slice_file))\n    slice = VolumeSlice(brain = self, name = f\"{name} ({self.subject_code})\", volume = slice_path)\n    self._slices[name] = slice\n    self._update_matrices(volume_files = [slice_path])\n    return slice\n</code></pre>"},{"location":"api-core-brain/#threebrainpy.core.brain.Brain.add_surfaces","title":"<code>add_surfaces(surface_type, hemesphere='both')</code>","text":"<p>Add a surface to the brain. The surface will be rendered in main canvas using surface (JavaScript class).</p> <p>Parameters:</p> Name Type Description Default <code>surface_type</code> <code>str</code> <p>The type of the surface, e.g. \"pial\", \"white\", \"inflated\", \"sphere\" (see <code>surf/</code> folder, usually <code>[lr]h.&lt;surface_type&gt;</code>).</p> required <code>hemesphere</code> <code>str</code> <p>The hemesphere of the surface, can be \"l\", \"r\", \"b\" (both). (default: \"both\")</p> <code>'both'</code> <p>Returns:</p> Type Description <code>dict | None</code> <p>A dictionary of surface instances if exist, with keys being the hemesphere.</p> <p>Examples:</p> <p>Adds <code>lh.pial</code> and <code>rh.pial</code> to the brain surfaces</p> <pre><code>&gt;&gt;&gt; brain.add_surfaces(surface_type = \"pial\", hemesphere = \"both\")\n</code></pre> Source code in <code>threebrainpy/core/brain.py</code> <pre><code>def add_surfaces(self, surface_type : str, hemesphere : str = \"both\") -&gt; dict | None:\n'''\n    Add a surface to the brain. The surface will be rendered in main canvas using surface (JavaScript class).\n    Args:\n        surface_type: The type of the surface, e.g. \"pial\", \"white\", \"inflated\", \"sphere\" (see `surf/` folder, usually `[lr]h.&lt;surface_type&gt;`).\n        hemesphere: The hemesphere of the surface, can be \"l\", \"r\", \"b\" (both). (default: \"both\")\n    Returns:\n        A dictionary of surface instances if exist, with keys being the hemesphere.\n    Examples:\n        Adds `lh.pial` and `rh.pial` to the brain surfaces\n        &gt;&gt;&gt; brain.add_surfaces(surface_type = \"pial\", hemesphere = \"both\")\n    '''\n    hemesphere_prefix = hemesphere.lower()[0]\n    if hemesphere_prefix == \"b\":\n        hemesphere_prefix = [\"lh\", \"rh\"]\n    elif hemesphere_prefix == \"l\":\n        hemesphere_prefix = [\"lh\"]\n    elif hemesphere_prefix == \"r\":\n        hemesphere_prefix = [\"rh\"]\n    else:\n        raise ValueError(f\"Invalid hemesphere: {hemesphere}\")\n    surface_type0 = surface_type\n    surface_type = surface_type.lower()\n    if surface_type in (\"pial\", \"pial.t1\",):\n        # Newer freesurfer versions use \"pial.T1\" as the surface type, while older versions use \"pial\"\n        surface_type = [\"pial\", \"pial.t1\"]\n        surface_type0 = \"pial\"\n    # construct possible file names\n    file_names_lower = []\n    for h in hemesphere_prefix:\n        for s in surface_type:\n            file_names_lower.append(f\"{h}.{s}\")\n    # search for the file\n    if not os.path.exists(self.path_surf):\n        return None\n    if not os.path.isdir(self.path_surf):\n        return None\n    surface_files = [x for x in os.listdir(self.path_surf) if x.lower() in file_names_lower]\n    if len(surface_files) == 0:\n        return None\n    surface_dict = self._surfaces.get(surface_type0, None)\n    if not isinstance(surface_dict, dict):\n        surface_dict = {}\n        self._surfaces[surface_type0] = surface_dict\n    # check base vertex colors\n    base_vertex_colors = self._surface_morph_paths()\n    for surface_filename in surface_files:\n        surface_file = os.path.join(self.path_surf, surface_filename)\n        surface = CorticalSurface(brain = self, surface_type = surface_type0, surface_file = surface_file, hemesphere = surface_filename[0])\n        surface_dict[ surface.hemesphere ] = surface\n        if isinstance(base_vertex_colors, dict):\n            surface.group.set_group_data(\n                name = f\"{surface.hemesphere}_primary_vertex_color\", \n                value = base_vertex_colors[surface.hemesphere], is_cache = True)\n    return surface_dict\n</code></pre>"},{"location":"api-core-brain/#threebrainpy.core.brain.Brain.add_volume","title":"<code>add_volume(volume_prefix, is_continuous, name=None)</code>","text":"<p>Add a (Atlas/CT/3D voxel) volume cube to the brain. The VolumeCube will be rendered in main canvas using datacube2 (JavaScript class).</p> <p>Parameters:</p> Name Type Description Default <code>volume_prefix</code> <code>str</code> <p>The prefix of the volume file in the <code>mri</code> folder. (e.g. \"aparc+aseg\", \"CT_raw\")</p> required <code>is_continuous</code> <code>bool</code> <p>Whether the volume is continuous or discrete.  The color map for continuous and discrete values are set separately. For continuous values, the volume will be rendered using RedFormat (single-channel shader).      The color will be assgined according to the volume value (density). For discrete values, the volume will be rendered using RGBAFormat (four-channel shader).      The volume data will be used as the color index, and the color map will be set separately.     The color index must be integer, and the color map must be a list of RGBA colors.</p> required <code>name</code> <code>str</code> <p>The name of the volume, default is to automatically derived from the volume_prefix.  Please set name to \"CT\" is the volume file is CT for localization</p> <code>None</code> <p>Examples:</p> <p>Adds <code>aparc+aseg.mgz</code> or <code>aparc+aseg.nii[.gz]</code> to the brain volumes</p> <pre><code>&gt;&gt;&gt; brain.add_volume(volume_prefix = \"aparc+aseg\", is_continuous = False)\n</code></pre> Source code in <code>threebrainpy/core/brain.py</code> <pre><code>def add_volume(self, volume_prefix : str, is_continuous : bool, name : str = None) -&gt; dict | None:\n'''\n    Add a (Atlas/CT/3D voxel) volume cube to the brain. The VolumeCube will be rendered in main canvas using datacube2 (JavaScript class).\n    Args:\n        volume_prefix: The prefix of the volume file in the `mri` folder. (e.g. \"aparc+aseg\", \"CT_raw\")\n        is_continuous: Whether the volume is continuous or discrete. \n            The color map for continuous and discrete values are set separately.\n            For continuous values, the volume will be rendered using RedFormat (single-channel shader). \n                The color will be assgined according to the volume value (density).\n            For discrete values, the volume will be rendered using RGBAFormat (four-channel shader). \n                The volume data will be used as the color index, and the color map will be set separately.\n                The color index must be integer, and the color map must be a list of RGBA colors.\n        name: The name of the volume, default is to automatically derived from the volume_prefix. \n            Please set name to \"CT\" is the volume file is CT for localization\n    Examples:\n        Adds `aparc+aseg.mgz` or `aparc+aseg.nii[.gz]` to the brain volumes\n        &gt;&gt;&gt; brain.add_volume(volume_prefix = \"aparc+aseg\", is_continuous = False)\n    '''\n    # In geoms, the name needs to be appended with the subject code\n    # possible file names\n    volume_prefix = volume_prefix.lower()\n    if name is None:\n        name = re.sub(r\"[^a-zA-Z0-9_]\", \"_\", volume_prefix)\n    candidates = [\n        f\"{volume_prefix}.mgz\",\n        f\"{volume_prefix}.nii.gz\",\n        f\"{volume_prefix}.nii\",\n    ]\n    volume_files = [x for x in os.listdir(self.path_mri) if x.lower() in candidates]\n    if len(volume_files) == 0:\n        return None\n    volume_file = volume_files[0]\n    volume_path = os.path.abspath(os.path.join(self.path_mri, volume_file))\n    volume = VolumeWrapper(volume_path)\n    volume_cube = VolumeCube(brain = self, name = f\"Atlas - {name} ({self.subject_code})\", volume = volume,\n                             color_format = \"RedFormat\" if is_continuous else \"RGBAFormat\")\n    self._update_matrices(volume_files = [volume_path])\n    self._volumes[name] = volume_cube\n    return volume_cube\n</code></pre>"},{"location":"api-core-brain/#threebrainpy.core.brain.Brain.build","title":"<code>build(path=None, dry_run=False)</code>","text":"<p>Build the brain cache. If <code>path</code> is not specified, the cache will be built under the temporary directory.</p> <p>Parameters:</p> Name Type Description Default <code>path</code> <code>str | None</code> <p>The path to build the cache; default is using the <code>self._storage</code> path.</p> <code>None</code> <code>dry_run</code> <code>bool</code> <p>If True, the cache will not be built, instead, the build process will be printed to the console.</p> <code>False</code> Source code in <code>threebrainpy/core/brain.py</code> <pre><code>def build(self, path : str | None = None, dry_run : bool = False):\n'''\n    Build the brain cache. If `path` is not specified, the cache will be built under the temporary directory.\n    Args:\n        path: The path to build the cache; default is using the `self._storage` path.\n        dry_run: If True, the cache will not be built, instead, the build process will be printed to the console.\n    '''\n    config = self.to_dict()\n    # Needs to generate a global data dict to include all global data for compatibility\n    build_global = BlankPlaceholder(brain = self, is_global = True)\n    build_group = GeomWrapper(brain = self, name = build_global.group_name)\n    config['geoms'].insert(0, build_global)\n    config['groups'].insert(0, build_group)\n    build_group.set_group_data(name = '__global_data__.subject_codes', value = [self.subject_code], is_cache = False)\n\n    # Construct colormaps\n    cmaps = {}\n    for _, colormap in self._electrode_cmaps.items():\n        cmap_data = colormap.to_dict()\n        if isinstance(cmap_data, dict):\n            cmaps[ colormap.name ] = cmap_data\n    default_cmap = list(cmaps.keys())[0] if len(cmaps) &gt; 0 else None\n\n    # Hard-code for now\n    build_group.set_group_data(\n        name = '__global_data__.SurfaceColorLUT', \n        value = template_path(f\"lib/threeBrain_data-0/{ build_group.cache_name }/ContinuousSample.json\"),\n        is_cache = True\n    )\n    build_group.set_group_data(\n        name = '__global_data__.VolumeColorLUT', \n        value = template_path(f\"lib/threeBrain_data-0/{ build_group.cache_name }/FreeSurferColorLUT.json\"),\n        is_cache = True\n    )\n    build_group.set_group_data(\n        name = '__global_data__.FSColorLUT', \n        value = template_path(f\"lib/threeBrain_data-0/{ build_group.cache_name }/FSColorLUT.json\"),\n        is_cache = True\n    )\n\n    settings = config['settings']\n    settings['title'] = \"\"\n    settings['side_camera'] = True\n    settings['side_canvas_zoom'] = 1\n    settings['side_canvas_width'] = 250\n    settings['side_canvas_shift'] = [0, 0]\n    settings['color_maps'] = cmaps\n    settings['default_colormap'] = default_cmap\n    settings['hide_controls'] = False\n    settings['control_center'] = [0, 0, 0]\n    settings['camera_pos'] = [500, 0, 0]\n    settings['font_magnification'] = 1\n    settings['start_zoom'] = 1\n    settings['show_legend'] = True\n    settings['render_timestamp'] = True\n    settings['control_presets'] = [\n        \"subject2\", \"surface_type2\", \"hemisphere_material\", \"surface_color\", \"map_template\",\n        \"electrodes\", \"voxel\", \"animation\", \"display_highlights\"\n    ]\n    settings['cache_folder'] = \"lib/threebrain_data-0/\"\n    settings['lib_path'] = \"lib/\"\n    settings['default_controllers'] = []\n    settings['debug'] = True\n    settings['background'] = \"#FFFFFF\"\n    settings['token'] = None\n    settings['show_inactive_electrodes'] = True\n    settings['side_display'] = True\n    settings['control_display'] = True\n    settings['custom_javascript'] = None\n\n    # write files\n    # dry_run = False\n    # path=os.path.join(ensure_default_temporary_directory(), \"test\")\n    if path is None:\n        path = self._storage.name\n    init_skeleton(path, dry_run = dry_run)\n    # for each group data, check if is_cache, if so, copy the file to the cache folder\n    for group in config['groups']:\n        group.build(path = path, dry_run = dry_run)\n    # construct config.json\n    if dry_run:\n        print(\"Writing config.json...\")\n    else:\n        import json\n        s = json.dumps({\n            \"groups\": config['groups'],\n            \"geoms\": config['geoms'],\n        }, cls = GeomEncoder)\n        with open(os.path.join(path, \"lib\", \"threebrain_data-0\", \"config.json\"), \"w\") as f:\n            f.write(s)\n\n    # construct index.html\n    if dry_run:\n        print(\"Writing index.html...\")\n    else:\n        with open(template_path(\"index.html\"), \"r\") as f:\n            index_content = \"\\n\".join(f.readlines())\n        index_content = index_content.replace(\"WIDGET_ID\", \"threebrainpy-viewer\")\n        widget_data = json.dumps({\n            'x' : {\n                'data_filename' : 'config.json',\n                \"force_render\":True,\n                'settings' : settings,\n            },\n            \"evals\":[],\"jsHooks\":[]\n        }, cls = GeomEncoder)\n        index_content = index_content.replace(\"WIDGET_DATA\", widget_data)\n        index_path = os.path.join(path, \"index.html\")\n        with open(index_path, \"w\") as f:\n            f.write(index_content)\n</code></pre>"},{"location":"api-core-brain/#threebrainpy.core.brain.Brain.clean_electrodes","title":"<code>clean_electrodes()</code>","text":"<p>Remove all electrode contacts from the brain.</p> Source code in <code>threebrainpy/core/brain.py</code> <pre><code>def clean_electrodes(self):\n'''\n    Remove all electrode contacts from the brain.\n    '''\n    contact_names = [contact.name for _, contact in self._electrode_contacts.items()]\n    for contact_name in contact_names:\n        self._geoms.pop(contact_name, None)\n        self._electrode_contacts.pop(contact_name, None)\n</code></pre>"},{"location":"api-core-brain/#threebrainpy.core.brain.Brain.ensure_group","title":"<code>ensure_group(name, **kwargs)</code>","text":"<p>Ensure that a geometry group exists, if not, create one.</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>The name of the group.</p> required <code>kwargs</code> <code>dict</code> <p>Other arguments to be passed to <code>add_group</code>.</p> <code>{}</code> <p>Returns:</p> Type Description <code>GeomWrapper</code> <p>The group instance.</p> Source code in <code>threebrainpy/core/brain.py</code> <pre><code>def ensure_group(self, name : str, **kwargs : dict) -&gt; GeomWrapper:\n'''\n    Ensure that a geometry group exists, if not, create one.\n    Args:\n        name: The name of the group.\n        kwargs: Other arguments to be passed to `add_group`.\n    Returns:\n        The group instance.\n    '''\n    if self.has_group(name):\n        return self.get_group(name)\n    return self.add_group(name = name, exists_ok = True, **kwargs)\n</code></pre>"},{"location":"api-core-brain/#threebrainpy.core.brain.Brain.get_electrode_colormap","title":"<code>get_electrode_colormap(name)</code>","text":"<p>Get the colormap of an electrode contact.</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>The name of the electrode keyframe (which is also the color-map name).</p> required <p>Returns:</p> Type Description <code>ElectrodeColormap | None</code> <p>The colormap instance or <code>None</code> if the colormap does not exist.</p> Source code in <code>threebrainpy/core/brain.py</code> <pre><code>def get_electrode_colormap(self, name : str) -&gt; ElectrodeColormap | None:\n'''\n    Get the colormap of an electrode contact.\n    Args:\n        name: The name of the electrode keyframe (which is also the color-map name).\n    Returns:\n        The colormap instance or `None` if the colormap does not exist.\n    '''\n    return self._electrode_cmaps.get(name, None)\n</code></pre>"},{"location":"api-core-brain/#threebrainpy.core.brain.Brain.get_electrode_contact","title":"<code>get_electrode_contact(number)</code>","text":"<p>Get an electrode contact from the brain.</p> <p>Parameters:</p> Name Type Description Default <code>number</code> <code>int</code> <p>The integer number of the electrode contact, starting from 1.</p> required <p>Returns:</p> Type Description <code>ElectrodeSphere | None</code> <p>The electrode contact instance or <code>None</code> if the electrode contact does not exist.</p> Source code in <code>threebrainpy/core/brain.py</code> <pre><code>def get_electrode_contact(self, number : int) -&gt; ElectrodeSphere | None:\n'''\n    Get an electrode contact from the brain.\n    Args:\n        number: The integer number of the electrode contact, starting from 1.\n    Returns:\n        The electrode contact instance or `None` if the electrode contact does not exist.\n    '''\n    return self._electrode_contacts.get(int(number), None)\n</code></pre>"},{"location":"api-core-brain/#threebrainpy.core.brain.Brain.get_geometry","title":"<code>get_geometry(name)</code>","text":"<p>Get a geometry instance from the brain.</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>The name of the geometry template.</p> required <p>Returns:</p> Type Description <code>GeometryTemplate | None</code> <p>The geometry instance or <code>None</code> if the geometry instance does not exist.</p> Source code in <code>threebrainpy/core/brain.py</code> <pre><code>def get_geometry(self, name : str) -&gt; GeometryTemplate | None:\n'''\n    Get a geometry instance from the brain.\n    Args:\n        name: The name of the geometry template.\n    Returns:\n        The geometry instance or `None` if the geometry instance does not exist.\n    '''\n    return self._geoms.get(name, None)\n</code></pre>"},{"location":"api-core-brain/#threebrainpy.core.brain.Brain.get_global_data","title":"<code>get_global_data(name, force_reload=False, ifnotfound=None)</code>","text":"<p>Get group data from the brain instance.</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>The name of the group data.</p> required <code>force_reload</code> <code>bool</code> <p>Whether to force reload the group data.</p> <code>False</code> <code>ifnotfound</code> <code>any | None</code> <p>If the group data is not found, return this value.</p> <code>None</code> <p>Returns:</p> Type Description <code>any</code> <p>The value of the group data, or <code>ifnotfound</code>.</p> Source code in <code>threebrainpy/core/brain.py</code> <pre><code>def get_global_data(self, name : str, force_reload : bool = False, ifnotfound : any | None = None) -&gt; any:\n'''\n    Get group data from the brain instance.\n    Args:\n        name: The name of the group data.\n        force_reload: Whether to force reload the group data.\n        ifnotfound: If the group data is not found, return this value.\n    Returns:\n        The value of the group data, or `ifnotfound`.\n    '''\n    group = self.get_group(name)\n    if group is None:\n        return ifnotfound\n    return group.get_group_data(name = name, force_reload = force_reload, ifnotfound = ifnotfound)\n</code></pre>"},{"location":"api-core-brain/#threebrainpy.core.brain.Brain.get_group","title":"<code>get_group(name)</code>","text":"<p>Get a geometry group from the brain.</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>The name of the group.</p> required <p>Returns:</p> Type Description <code>GeomWrapper | None</code> <p>The group instance or <code>None</code> if the group does not exist.</p> Source code in <code>threebrainpy/core/brain.py</code> <pre><code>def get_group(self, name : str) -&gt; GeomWrapper | None:\n'''\n    Get a geometry group from the brain.\n    Args:\n        name: The name of the group.\n    Returns:\n        The group instance or `None` if the group does not exist.\n    '''\n    return self._groups.get(name, None)\n</code></pre>"},{"location":"api-core-brain/#threebrainpy.core.brain.Brain.get_slice","title":"<code>get_slice(name)</code>","text":"<p>Get MRI slices from the brain.</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>The name of the slice.</p> required <p>Returns:</p> Type Description <code>VolumeSlice | None</code> <p>The slice instance or <code>None</code> if the slice does not exist.</p> Source code in <code>threebrainpy/core/brain.py</code> <pre><code>def get_slice(self, name : str) -&gt; VolumeSlice | None:\n'''\n    Get MRI slices from the brain.\n    Args:\n        name: The name of the slice.\n    Returns:\n        The slice instance or `None` if the slice does not exist.\n    '''\n    return self._slices.get(name, None)\n</code></pre>"},{"location":"api-core-brain/#threebrainpy.core.brain.Brain.get_slices","title":"<code>get_slices()</code>","text":"<p>Get all MRI slices from the brain.</p> Source code in <code>threebrainpy/core/brain.py</code> <pre><code>def get_slices(self) -&gt; list[VolumeSlice]:\n'''\n    Get all MRI slices from the brain.\n    '''\n    return self._slices\n</code></pre>"},{"location":"api-core-brain/#threebrainpy.core.brain.Brain.get_surfaces","title":"<code>get_surfaces(surface_type)</code>","text":"<p>Get surfaces from the brain.</p> <p>Parameters:</p> Name Type Description Default <code>surface_type</code> <code>str</code> <p>The type of the surface, e.g. \"pial\", \"white\", \"inflated\", \"sphere\" (see <code>surf/</code> folder, usually <code>[lr]h.&lt;surface_type&gt;</code>).</p> required <p>Returns:</p> Type Description <code>dict | None</code> <p>A dictionary of surface instances if exist, with keys being the hemesphere.</p> Source code in <code>threebrainpy/core/brain.py</code> <pre><code>def get_surfaces(self, surface_type : str) -&gt; dict | None:\n'''\n    Get surfaces from the brain.\n    Args:\n        surface_type: The type of the surface, e.g. \"pial\", \"white\", \"inflated\", \"sphere\" (see `surf/` folder, usually `[lr]h.&lt;surface_type&gt;`).\n    Returns:\n        A dictionary of surface instances if exist, with keys being the hemesphere.\n    '''\n    return self._surfaces.get(surface_type, None)\n</code></pre>"},{"location":"api-core-brain/#threebrainpy.core.brain.Brain.get_transform","title":"<code>get_transform(space_from, space_to)</code>","text":"<p>Get transform matrix from <code>space_from</code> to <code>space_to</code>. </p> <p>Parameters:</p> Name Type Description Default <code>space_from</code> <code>str</code> <p>The space from which the transform matrix is defined. choices are <code>voxel</code>, <code>ras</code>, <code>ras_tkr</code>, <code>mni305</code>, <code>mni152</code>.</p> required <code>space_to</code> <code>str</code> <p>The space to which the transform matrix is defined. see <code>space_from</code> for choices.</p> required <p>Examples:</p> <pre><code>&gt;&gt;&gt; brain.get_transform(space_from = \"voxel\", space_to = \"ras_tkr\")\nMat44 (T1.voxel -&gt; T1.ras_tkr): \narray([[  -1.,    0.,    0.,  128.],\n    [   0.,    0.,    1., -128.],\n    [   0.,   -1.,    0.,  128.],\n    [   0.,    0.,    0.,    1.]])\n</code></pre> Source code in <code>threebrainpy/core/brain.py</code> <pre><code>def get_transform(self, space_from : str, space_to : str) -&gt; Mat44:\n'''\n    Get transform matrix from `space_from` to `space_to`. \n    Args:\n        space_from: The space from which the transform matrix is defined.\n            choices are `voxel`, `ras`, `ras_tkr`, `mni305`, `mni152`.\n        space_to: The space to which the transform matrix is defined.\n            see `space_from` for choices.\n    Examples:\n        &gt;&gt;&gt; brain.get_transform(space_from = \"voxel\", space_to = \"ras_tkr\")\n        Mat44 (T1.voxel -&gt; T1.ras_tkr): \n        array([[  -1.,    0.,    0.,  128.],\n            [   0.,    0.,    1., -128.],\n            [   0.,   -1.,    0.,  128.],\n            [   0.,    0.,    0.,    1.]])\n    '''\n    if space_from not in CONSTANTS.SUPPORTED_SPACES:\n        raise ValueError(f\"Invalid space_from: {space_from}, supported spaces are: {CONSTANTS.SUPPORTED_SPACES}\")\n    if space_to not in CONSTANTS.SUPPORTED_SPACES:\n        raise ValueError(f\"Invalid space_to: {space_to}, supported spaces are: {CONSTANTS.SUPPORTED_SPACES}\")\n    if space_from == space_to:\n        return Mat44(space_from=space_from, space_to=space_to, modality_from=\"T1\", modality_to=\"T1\")\n    if space_from == \"ras\":\n        transform = Mat44(space_from=\"ras\", space_to=\"ras\", modality_from=\"T1\", modality_to=\"T1\")\n    elif space_from == \"ras_tkr\":\n        transform = deepcopy(~self.ras2ras_tkr)\n    elif space_from == \"mni305\":\n        transform = deepcopy(~self.ras2mni_305)\n    elif space_from == \"mni152\":\n        transform = deepcopy(~self.ras2mni_152)\n    else:\n        transform = deepcopy(self.vox2ras)\n    if space_to == \"ras\":\n        return transform\n    elif space_to == \"ras_tkr\":\n        return self.ras2ras_tkr * transform\n    elif space_to == \"mni305\":\n        return self.ras2mni_305 * transform\n    elif space_to == \"mni152\":\n        return self.ras2mni_152 * transform\n    else:\n        return (~self.vox2ras) * transform\n</code></pre>"},{"location":"api-core-brain/#threebrainpy.core.brain.Brain.has_geometry","title":"<code>has_geometry(name)</code>","text":"<p>Check if the brain has a geometry instance.</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>The name of the geometry template.</p> required <p>Returns:</p> Type Description <code>bool</code> <p><code>True</code> if the geometry instance exists, <code>False</code> otherwise.</p> Source code in <code>threebrainpy/core/brain.py</code> <pre><code>def has_geometry(self, name : str) -&gt; bool:\n'''\n    Check if the brain has a geometry instance.\n    Args:\n        name: The name of the geometry template.\n    Returns:\n        `True` if the geometry instance exists, `False` otherwise.\n    '''\n    return name in self._geoms\n</code></pre>"},{"location":"api-core-brain/#threebrainpy.core.brain.Brain.has_group","title":"<code>has_group(name)</code>","text":"<p>Check if the brain has a geometry group.</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>The name of the group.</p> required <p>Returns:</p> Type Description <code>bool</code> <p><code>True</code> if the group exists, <code>False</code> otherwise.</p> Source code in <code>threebrainpy/core/brain.py</code> <pre><code>def has_group(self, name : str) -&gt; bool:\n'''\n    Check if the brain has a geometry group.\n    Args:\n        name: The name of the group.\n    Returns:\n        `True` if the group exists, `False` otherwise.\n    '''\n    return name in self._groups\n</code></pre>"},{"location":"api-core-brain/#threebrainpy.core.brain.Brain.has_slice","title":"<code>has_slice(name)</code>","text":"<p>Check if the brain has MRI slices with given name.</p> Source code in <code>threebrainpy/core/brain.py</code> <pre><code>def has_slice(self, name : str) -&gt; bool:\n'''\n    Check if the brain has MRI slices with given name.\n    '''\n    return name in self._slices\n</code></pre>"},{"location":"api-core-brain/#threebrainpy.core.brain.Brain.has_surface_type","title":"<code>has_surface_type(surface_type)</code>","text":"<p>Check if the brain has surfaces with given type.</p> <p>Parameters:</p> Name Type Description Default <code>surface_type</code> <code>str</code> <p>The type of the surface, e.g. \"pial\", \"white\", \"inflated\", \"sphere\" (see <code>surf/</code> folder, usually <code>[lr]h.&lt;surface_type&gt;</code>).</p> required Source code in <code>threebrainpy/core/brain.py</code> <pre><code>def has_surface_type(self, surface_type : str) -&gt; bool:\n'''\n    Check if the brain has surfaces with given type.\n    Args:\n        surface_type: The type of the surface, e.g. \"pial\", \"white\", \"inflated\", \"sphere\" (see `surf/` folder, usually `[lr]h.&lt;surface_type&gt;`).\n    '''\n    return surface_type in self._surfaces\n</code></pre>"},{"location":"api-core-brain/#threebrainpy.core.brain.Brain.set_electrode_keyframe","title":"<code>set_electrode_keyframe(number, value, time=None, name='value')</code>","text":"<p>Low-level method to set electrode contacts keyframe (values).</p> <p>Parameters:</p> Name Type Description Default <code>number</code> <code>int</code> <p>The integer number of the electrode contact, starting from 1.</p> required <code>value</code> <code>ndarray | list[float] | list[int] | list[str] | float | int | str</code> <p>The value of the keyframe, can be numerical or characters.</p> required <code>time</code> <code>float | list[float] | tuple(float) | ndarray | None</code> <p>The time (second) of the keyframe, default is <code>None</code> which means 0.</p> <code>None</code> <code>name</code> <code>str</code> <p>The name of the keyframe, default is \"value\".</p> <code>'value'</code> <p>Returns:</p> Type Description <code>SimpleKeyframe | None</code> <p>The keyframe created</p> Source code in <code>threebrainpy/core/brain.py</code> <pre><code>def set_electrode_keyframe(self, number : int, value : np.ndarray | list[float] | list[int] | list[str] | float | int | str, \n                           time : float | list[float] | tuple(float) | np.ndarray | None = None, \n                           name : str = \"value\") -&gt; SimpleKeyframe | None:\n'''\n    Low-level method to set electrode contacts keyframe (values).\n    Args:\n        number: The integer number of the electrode contact, starting from 1.\n        value: The value of the keyframe, can be numerical or characters.\n        time: The time (second) of the keyframe, default is `None` which means 0.\n        name: The name of the keyframe, default is \"value\".\n    Returns:\n        The keyframe created\n    '''\n    contact = self._electrode_contacts.get(int(number), None)\n    if contact is None:\n        return None\n    return contact.set_keyframe(value = value, time = time, name = name)\n</code></pre>"},{"location":"api-core-brain/#threebrainpy.core.brain.Brain.set_electrode_value","title":"<code>set_electrode_value(number, name, value, time=None)</code>","text":"<p>Set value to a electrode contact.</p> <p>Parameters:</p> Name Type Description Default <code>number</code> <code>int</code> <p>The electrode contact number.</p> required <code>name</code> <code>str</code> <p>The data name of the value.</p> required <code>value</code> <code>list[float] | list[str] | dict | float | str</code> <p>The value to set, can be a list of values or a single value.</p> required <code>time</code> <code>list[float] | float | None</code> <p>The time of the value, can be a list of times (in seconds) or a single time.</p> <code>None</code> <p>Returns:</p> Type Description <code>SimpleKeyframe | None</code> <p>The keyframe object or None if the electrode contact is not found.</p> Source code in <code>threebrainpy/core/brain.py</code> <pre><code>def set_electrode_value(self, number : int, name : str, value : list[float] | list[str] | dict | float | str, \n                        time : list[float] | float | None = None) -&gt; SimpleKeyframe | None:\n'''\n    Set value to a electrode contact.\n    Args:\n        number: The electrode contact number.\n        name: The data name of the value.\n        value: The value to set, can be a list of values or a single value.\n        time: The time of the value, can be a list of times (in seconds) or a single time.\n    Returns: \n        The keyframe object or None if the electrode contact is not found.\n    '''\n    contact = self._electrode_contacts.get(int(number), None)\n    if contact is None:\n        return None\n    return contact.set_keyframe(value = value, time = time, name = name)\n</code></pre>"},{"location":"api-core-brain/#threebrainpy.core.brain.Brain.set_electrode_values","title":"<code>set_electrode_values(table)</code>","text":"<p>Set single or multiple values to multiple electrode contacts.</p> <p>Parameters:</p> Name Type Description Default <code>table</code> <code>str | DataFrame</code> <p>A pandas or a path to a csv file. The see 'Details' for table contents</p> required Details <p>The table (or table file) contains the following columns (case-sensitive):</p> <ul> <li><code>Electrode</code> (mandatory): The electrode contact number, starting from 1</li> <li><code>Subject</code> (optional): The subject code of the value, default is the current subject code</li> <li><code>Time</code> (optional): The numeric time of the value, in seconds</li> <li>All other columns: The the column names are the data names of the values, can      be combinations of letters <code>[a-zA-Z]</code>, numbers <code>[0-9]</code>, dots <code>.</code>, and underscores <code>_</code></li> </ul> <p>Examples:</p> <p>The minimal table contains only the electrode contact number and the value:</p> Electrode brain.response 1 0.1 2 0.2 3 0.3 <p>Here's an example of the table with two variables <code>brain.response</code> and <code>classifier</code>,  and two electrodes <code>1</code> and <code>2</code>. The time range is <code>0~1</code> seconds.</p> Electrode Time brain.response classifier 1 0 0.1 A 1 1 0.2 A 2 0 0.3 A 2 1 0.4 B Source code in <code>threebrainpy/core/brain.py</code> <pre><code>def set_electrode_values(self, table : str | DataFrame):\n'''\n    Set single or multiple values to multiple electrode contacts.\n    Args: \n        table: A pandas or a path to a csv file. The see 'Details' for table contents\n    Details:\n        The table (or table file) contains the following columns (**case-sensitive**):\n\n        * `Electrode` (mandatory): The electrode contact number, starting from 1\n        * `Subject` (optional): The subject code of the value, default is the current subject code\n        * `Time` (optional): The numeric time of the value, in seconds\n        * All other columns: The the column names are the data names of the values, can \n            be combinations of letters `[a-zA-Z]`, numbers `[0-9]`, dots `.`, and underscores `_`\n    Examples:\n        The minimal table contains only the electrode contact number and the value:\n\n        | Electrode | brain.response |\n        |-----------|----------------|\n        | 1         | 0.1            |\n        | 2         | 0.2            |\n        | 3         | 0.3            |\n\n\n        Here's an example of the table with two variables `brain.response` and `classifier`, \n        and two electrodes `1` and `2`. The time range is `0~1` seconds.\n\n        | Electrode | Time | brain.response | classifier |\n        |-----------|------|----------------|------------|\n        | 1         | 0    | 0.1            | A          |\n        | 1         | 1    | 0.2            | A          |\n        | 2         | 0    | 0.3            | A          |\n        | 2         | 1    | 0.4            | B          |\n    '''\n    if isinstance(table, str):\n        # table = \"/Users/dipterix/rave_data/data_dir/demo/DemoSubject/rave/meta/electrodes.csv\"\n        import pandas as pd\n        table = pd.read_csv(table, sep = \",\")\n    # assume table is pandas since we don't want to import pandas here\n    if \"Electrode\" not in table.columns:\n        raise LookupError(f\"Invalid table, must contain column 'Electrode'.\")\n    time = table.get(\"Time\", None)\n    subjects = table.get(\"Subject\", None)\n    electrodes = table[\"Electrode\"]\n    electrode_numbers = electrodes.unique()\n    var_names = [x for x in table.columns if x not in [\"Electrode\", \"Time\"]]\n    if subjects is not None:\n        subjects = subjects == self.subject_code\n    else:\n        subjects = True\n    for electrode in electrode_numbers:\n        sel = (electrodes == electrode) &amp; subjects\n        if sel.size &gt; 0 and sel.sum() &gt; 0:\n            for name in var_names:\n                keyframe = self.set_electrode_value(\n                    number = electrode, name = name, value = table[name][sel].tolist(), \n                    time = None if time is None else time[sel])\n                if isinstance(keyframe, SimpleKeyframe):\n                    # get colormap\n                    colormap = self._electrode_cmaps.get(name, None)\n                    if colormap is None:\n                        colormap = ElectrodeColormap(keyframe_name = keyframe, value_type = \"continuous\" if keyframe.is_continuous else \"discrete\")\n                        self._electrode_cmaps[name] = colormap\n                    colormap.update_from_keyframe( keyframe = keyframe )\n    return \n</code></pre>"},{"location":"api-core-brain/#threebrainpy.core.brain.Brain.set_group_data","title":"<code>set_group_data(name, value, is_cache=False, absolute_path=None, auto_create=True)</code>","text":"<p>Set group data to the brain so the JavaScript engine will have access to the data.      This method is a low-level function</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>The name of the group data.</p> required <code>value</code> <code>any | str</code> <p>If <code>is_cache=False</code>, the value of the group data, can be any JSON-serializable object. If <code>is_cache=True</code>, the path to, or the file name of the cached JSON file.</p> required <code>is_cache</code> <code>bool</code> <p>Whether the <code>value</code> is a cached JSON file.</p> <code>False</code> <code>absolute_path</code> <code>str | None</code> <p>The absolute path to the cached JSON file.</p> <code>None</code> <code>auto_create</code> <code>bool</code> <p>Whether to create a group if the group does not exist.</p> <code>True</code> Source code in <code>threebrainpy/core/brain.py</code> <pre><code>def set_group_data(self, name : str, value : any | str, is_cache : bool = False, absolute_path : str | None = None, auto_create : bool = True) -&gt; None:\n'''\n    Set group data to the brain so the JavaScript engine will have access to the data. \n        This method is a low-level function\n    Args:\n        name: The name of the group data.\n        value: If `is_cache=False`, the value of the group data, can be any JSON-serializable object.\n            If `is_cache=True`, the path to, or the file name of the cached JSON file.\n        is_cache: Whether the `value` is a cached JSON file.\n        absolute_path: The absolute path to the cached JSON file.\n        auto_create: Whether to create a group if the group does not exist.\n    '''\n    if auto_create:\n        self.ensure_group(name = name)\n    group = self.get_group(name)\n    if group is None:\n        raise ValueError(f\"Group {name} not found.\")\n    group.set_group_data(name = name, value = value, is_cache = is_cache, absolute_path = absolute_path)\n    return None\n</code></pre>"},{"location":"api-core-brain/#threebrainpy.core.brain.Brain.set_transform_space","title":"<code>set_transform_space(transform, space_from, space_to)</code>","text":"<p>Returns a copy of <code>transform</code>, but with space transformed. </p> <p>Parameters:</p> Name Type Description Default <code>transform</code> <code>Mat44</code> <p>The transform matrix of class <code>Mat44</code>. If <code>transform</code> is not specified, then the transform will be identity matrix.</p> required <code>space_from</code> <code>str</code> <p>The space from which the transform matrix will be defined. choices are <code>voxel</code>, <code>ras</code>, <code>ras_tkr</code>, <code>mni305</code>, <code>mni152</code>.</p> required <code>space_to</code> <code>str</code> <p>The space to which the transform matrix will be defined.</p> required <p>Returns:</p> Type Description <code>Mat44</code> <p>The new transform matrix with given spaces and inherited modalities.</p> <p>Examples:</p> <p>If you have a matrix that switch the column and row indexes in the voxel space,     what's the matrix in the ras space?</p> <pre><code>&gt;&gt;&gt; from threebrainpy.core import Mat44\n&gt;&gt;&gt; idx_transform = Mat44([0,1,0,0,1,0,0,0,0,0,1,0], space_from = \"voxel\", space_to = \"voxel\")\n&gt;&gt;&gt; idx_transform\nMat44 (T1.voxel -&gt; T1.voxel): \narray([[0., 1., 0., 0.],\n    [1., 0., 0., 0.],\n    [0., 0., 1., 0.],\n    [0., 0., 0., 1.]])\n&gt;&gt;&gt; # Applies idx_transform first then vox-to-ras\n&gt;&gt;&gt; brain.set_transform_space(transform = idx_transform, space_from = \"voxel\", space_to = \"ras\")\nMat44 (T1.voxel -&gt; T1.ras): \narray([[   0.        ,   -1.        ,    0.        ,  131.61447144],\n    [   0.        ,    0.        ,    1.        , -127.5       ],\n    [  -1.        ,    0.        ,    0.        ,  127.5       ],\n    [   0.        ,    0.        ,    0.        ,    1.        ]])\n&gt;&gt;&gt; # To validate the transform\n&gt;&gt;&gt; brain.vox2ras * idx_transform\nMat44 (T1.voxel -&gt; T1.ras): \narray([[   0.        ,   -1.        ,    0.        ,  131.61447144],\n    [   0.        ,    0.        ,    1.        , -127.5       ],\n    [  -1.        ,    0.        ,    0.        ,  127.5       ],\n    [   0.        ,    0.        ,    0.        ,    1.        ]])\n</code></pre> Source code in <code>threebrainpy/core/brain.py</code> <pre><code>def set_transform_space(self, transform : Mat44, space_from : str, space_to : str) -&gt; Mat44:\n'''\n    Returns a copy of `transform`, but with space transformed. \n    Args:\n        transform: The transform matrix of class `Mat44`. If `transform` is not specified, then the transform will be identity matrix.\n        space_from: The space from which the transform matrix will be defined.\n            choices are `voxel`, `ras`, `ras_tkr`, `mni305`, `mni152`.\n        space_to: The space to which the transform matrix will be defined.\n    Returns:\n        The new transform matrix with given spaces and inherited modalities.\n    Examples:\n        If you have a matrix that switch the column and row indexes in the voxel space,\n            what's the matrix in the ras space?\n        &gt;&gt;&gt; from threebrainpy.core import Mat44\n        &gt;&gt;&gt; idx_transform = Mat44([0,1,0,0,1,0,0,0,0,0,1,0], space_from = \"voxel\", space_to = \"voxel\")\n        &gt;&gt;&gt; idx_transform\n        Mat44 (T1.voxel -&gt; T1.voxel): \n        array([[0., 1., 0., 0.],\n            [1., 0., 0., 0.],\n            [0., 0., 1., 0.],\n            [0., 0., 0., 1.]])\n        &gt;&gt;&gt; # Applies idx_transform first then vox-to-ras\n        &gt;&gt;&gt; brain.set_transform_space(transform = idx_transform, space_from = \"voxel\", space_to = \"ras\")\n        Mat44 (T1.voxel -&gt; T1.ras): \n        array([[   0.        ,   -1.        ,    0.        ,  131.61447144],\n            [   0.        ,    0.        ,    1.        , -127.5       ],\n            [  -1.        ,    0.        ,    0.        ,  127.5       ],\n            [   0.        ,    0.        ,    0.        ,    1.        ]])\n        &gt;&gt;&gt; # To validate the transform\n        &gt;&gt;&gt; brain.vox2ras * idx_transform\n        Mat44 (T1.voxel -&gt; T1.ras): \n        array([[   0.        ,   -1.        ,    0.        ,  131.61447144],\n            [   0.        ,    0.        ,    1.        , -127.5       ],\n            [  -1.        ,    0.        ,    0.        ,  127.5       ],\n            [   0.        ,    0.        ,    0.        ,    1.        ]])\n    '''\n    if not isinstance(transform, Mat44):\n        raise TypeError(f\"Invalid transform matrix: {transform}\")\n    if space_from not in CONSTANTS.SUPPORTED_SPACES:\n        raise ValueError(f\"Invalid space_from: {space_from}, supported spaces are: {CONSTANTS.SUPPORTED_SPACES}\")\n    if space_to not in CONSTANTS.SUPPORTED_SPACES:\n        raise ValueError(f\"Invalid space_to: {space_to}, supported spaces are: {CONSTANTS.SUPPORTED_SPACES}\")\n    # check modalities\n    if transform.modality_from != \"T1\" and transform.space_from != space_from:\n        raise ValueError(f\"Invalid transform matrix: {transform}, modality_from must be 'T1' or space_from must be {space_from}.\")\n    if transform.modality_to != \"T1\" and transform.space_to != space_to:\n        raise ValueError(f\"Invalid transform matrix: {transform}, modality_to must be 'T1' or space_to must be {space_to}.\")\n    re = deepcopy(transform)\n    if transform.modality_from == \"T1\":\n        re = re * self.get_transform(space_to = transform.space_from, space_from = space_from)\n    if transform.modality_to == \"T1\":\n        re = self.get_transform(space_from = transform.space_to, space_to = space_to) * re\n    return re\n</code></pre>"},{"location":"api-core-brain/#threebrainpy.core.brain.Brain.to_dict","title":"<code>to_dict()</code>","text":"<p>Convert the brain to a dict.</p> <p>Returns:</p> Type Description <code>dict</code> <p>A dict containing the brain data.</p> Source code in <code>threebrainpy/core/brain.py</code> <pre><code>def to_dict(self) -&gt; dict:\n'''\n    Convert the brain to a dict.\n    Returns: \n        A dict containing the brain data.\n    '''\n    # global_data needs to be rebuilt\n    self._globals.set_group_data(\n        name = \"subject_data\", \n        is_cache = False,\n        value = {\n            'subject_code' : self.subject_code,\n            'Norig': self.vox2ras.mat.tolist(),\n            'Torig': self.vox2ras_tkr.mat.tolist(),\n            'xfm': self.ras2mni_305.mat.tolist(),\n            # FreeSurfer RAS to MNI305, should be ras_tkr2mni_305, but for compatibility, vox2vox_MNI305\n            'vox2vox_MNI305': self.ras_tkr2mni_305.mat.tolist(),\n            # -(self$Norig %*% solve( self$Torig ) %*% c(0,0,0,1))[1:3]\n            'volume_types' : list(self._slices.keys()),\n            'atlas_types' : [], # self._atlases.keys()\n        })\n    geom_list = []\n    group_list = []\n    for _, geom in self._geoms.items():\n        geom_list.append(geom)\n    for _, group in self._groups.items():\n        group_list.append(group)\n    # The config file should contain groups and geoms\n    return {\n        'subject_code': self.subject_code,\n        'storage': self.storage.name,\n        'path': self.path,\n        \"settings\": {},\n        \"groups\": group_list,\n        \"geoms\": geom_list,\n    }\n</code></pre>"},{"location":"api-core-mat44/","title":"<code>&lt;Class Mat44&gt;</code>","text":"<p>             Bases: <code>object</code></p> <p>A 4x4 matrix for 3D affine transformation.</p> <p>Parameters:</p> Name Type Description Default <code>mat</code> <code>ndarray | list | tuple | None</code> <p>The matrix, can be a 1D array of length 12 or 16, or a 2D array of shape (3,4) or (4,4).</p> <code>None</code> <code>byrow</code> <code>bool</code> <p>Whether the matrix is in row-major order (default) or column-major order.</p> <code>True</code> <code>space_from</code> <code>str</code> <p>The space from which the matrix is defined, choices are \"ras\", \"voxel\", \"ras_tkr\", \"mni305\", \"mni152\".</p> <ul> <li>\"ras\": scanner-RAS space</li> <li>\"voxel\": voxel indexing space (or IJK space)</li> <li>\"ras_tkr\": FreeSurfer RAS space, this is the space used internally by the viewer engine in JavaScript</li> <li>\"mni305\": MNI305 template space</li> <li>\"mni152\": MNI152 template space</li> </ul> <p>threebrainpy does not limit the choices, but the viewer only supports these spaces.</p> <code>'ras'</code> <code>space_to</code> <code>str</code> <p>The space to which the matrix is defined, choices are the same as <code>space_from</code>.</p> <code>'ras'</code> <code>modality_from</code> <code>str</code> <p>The imaging modality from which the matrix is defined, choices are \"T1\" or \"CT\" other modalities may be  added in the future, default is \"T1\".</p> <code>'T1'</code> <code>modality_to</code> <code>str</code> <p>The imaging modality to which the matrix is defined. If set to <code>None</code>, then it will be set with the same value as <code>modality_from</code> automatically; default choice is <code>None</code>.</p> <code>'T1'</code> <p>Examples:</p> <pre><code>&gt;&gt;&gt; Mat44([1,2,3,4,5,6,7,8,9,10,11,12])\nMat44 (T1.ras -&gt; T1.ras): \narray([[ 1.,  2.,  3.,  4.],\n    [ 5.,  6.,  7.,  8.],\n    [ 9., 10., 11., 12.],\n    [ 0.,  0.,  0.,  1.]])\n&gt;&gt;&gt; Mat44([1,2,3,4,5,6,7,8,9,10,11,12], byrow=False)\nMat44 (T1.ras -&gt; T1.ras): \narray([[ 1.,  4.,  7., 10.],\n    [ 2.,  5.,  8., 11.],\n    [ 3.,  6.,  9., 12.],\n    [ 0.,  0.,  0.,  1.]])\n&gt;&gt;&gt; Mat44([-1,0,0,128,0,0,1,-128,0,-1,0,128], space_from=\"voxel\", space_to=\"ras_tkr\")\nMat44 (T1.voxel -&gt; T1.ras_tkr): \narray([[  -1.,    0.,    0.,  128.],\n    [   0.,    0.,    1., -128.],\n    [   0.,   -1.,    0.,  128.],\n    [   0.,    0.,    0.,    1.]])\n</code></pre> Source code in <code>threebrainpy/core/mat44.py</code> <pre><code>class Mat44(object):\n'''\n    A 4x4 matrix for 3D affine transformation.\n    Args:\n        mat: The matrix, can be a 1D array of length 12 or 16, or a 2D array of shape (3,4) or (4,4).\n        byrow: Whether the matrix is in row-major order (default) or column-major order.\n        space_from: The space from which the matrix is defined, choices are \"ras\", \"voxel\", \"ras_tkr\", \"mni305\", \"mni152\".\n\n            * \"ras\": scanner-RAS space\n            * \"voxel\": voxel indexing space (or IJK space)\n            * \"ras_tkr\": FreeSurfer RAS space, this is the space used internally by the viewer engine in JavaScript\n            * \"mni305\": MNI305 template space\n            * \"mni152\": MNI152 template space\n\n            &gt; threebrainpy does not limit the choices, but the viewer only supports these spaces.\n\n        space_to: The space to which the matrix is defined, choices are the same as `space_from`.\n        modality_from: The imaging modality from which the matrix is defined, choices are \"T1\" or \"CT\" other modalities may be \n            added in the future, default is \"T1\".\n        modality_to: The imaging modality to which the matrix is defined. If set to `None`, then it will be set\n            with the same value as `modality_from` automatically; default choice is `None`.\n\n    Examples:\n\n        &gt;&gt;&gt; Mat44([1,2,3,4,5,6,7,8,9,10,11,12])\n        Mat44 (T1.ras -&gt; T1.ras): \n        array([[ 1.,  2.,  3.,  4.],\n            [ 5.,  6.,  7.,  8.],\n            [ 9., 10., 11., 12.],\n            [ 0.,  0.,  0.,  1.]])\n        &gt;&gt;&gt; Mat44([1,2,3,4,5,6,7,8,9,10,11,12], byrow=False)\n        Mat44 (T1.ras -&gt; T1.ras): \n        array([[ 1.,  4.,  7., 10.],\n            [ 2.,  5.,  8., 11.],\n            [ 3.,  6.,  9., 12.],\n            [ 0.,  0.,  0.,  1.]])\n        &gt;&gt;&gt; Mat44([-1,0,0,128,0,0,1,-128,0,-1,0,128], space_from=\"voxel\", space_to=\"ras_tkr\")\n        Mat44 (T1.voxel -&gt; T1.ras_tkr): \n        array([[  -1.,    0.,    0.,  128.],\n            [   0.,    0.,    1., -128.],\n            [   0.,   -1.,    0.,  128.],\n            [   0.,    0.,    0.,    1.]])\n    '''\n    def __init__(self, mat : np.ndarray | list | tuple | None = None, byrow : bool = True, \n                 space_from : str = 'ras', space_to : str = 'ras', \n                 modality_from : str = \"T1\", modality_to : str = \"T1\"):\n        if mat is None:\n            self.mat = np.eye(4)\n        else:\n            mat = np.array(mat, copy = True, dtype=float)\n            if mat.size == 12:\n                if byrow:\n                    mat = mat.reshape(3,4)\n                else:\n                    mat = mat.reshape(4,3).transpose()\n                map = np.append(mat, [[0,0,0,1]], axis=0)\n            else:\n                map = mat.reshape(4, 4)\n                if not byrow:\n                    mat = mat.transpose()\n            self.mat = map\n        self.space_from = space_from\n        self.space_to = space_to\n        self.modality_from = modality_from\n        self.modality_to = modality_from if modality_to is None else modality_to\n        self.extra = {}\n\n    def __mul__(self, other):\n        if isinstance(other, Mat44):\n            # modalities must match\n            if self.modality_from != other.modality_to:\n                raise ValueError(f\"Mat44 multiply: modalities must match, but got {self.modality_from} and {other.modality_to}\")\n            # spaces must match\n            if self.space_from != other.space_to:\n                raise ValueError(f\"Mat44 multiply: spaces must match, but got {self.space_from} and {other.space_to}\")\n        return Mat44(np.matmul(self.mat, other.mat), modality_from=other.modality_from, modality_to=self.modality_to, space_from=other.space_from, space_to=self.space_to)\n\n    def __repr__(self):\n        re = repr(self.mat)\n        return f\"Mat44 ({self.modality_from}.{self.space_from} -&gt; {self.modality_to}.{self.space_to}): \\n{ re }\"\n\n    def __str__(self):\n        return str(self.mat)\n\n    def __getitem__(self, key):\n        return self.mat[key]\n\n    def __setitem__(self, key, value):\n        self.mat[key] = value\n\n    def __eq__(self, other):\n        return np.allclose(self.mat, other.mat)\n\n    def __ne__(self, other):\n        return not np.allclose(self.mat, other.mat)\n\n    def __hash__(self):\n        return hash(str(self.mat))\n\n    def __copy__(self):\n        return Mat44(self.mat.copy(), space_from = self.space_from, space_to = self.space_to, modality_from = self.modality_from, modality_to = self.modality_to)\n\n    def __deepcopy__(self, memo):\n        return Mat44(self.mat.copy(), space_from = self.space_from, space_to = self.space_to, modality_from = self.modality_from, modality_to = self.modality_to)\n\n    def __iter__(self):\n        return iter(self.mat)\n\n    def __len__(self):\n        return len(self.mat)\n\n    def __abs__(self):\n        return abs(self.mat)\n\n    def __neg__(self):\n        return Mat44(-self.mat, space_from = self.space_from, space_to = self.space_to, modality_from = self.modality_from, modality_to = self.modality_to)\n\n    def __pos__(self):\n        return Mat44(+self.mat, space_from = self.space_from, space_to = self.space_to, modality_from = self.modality_from, modality_to = self.modality_to)\n\n    def __add__(self, other):\n        if isinstance(other, Mat44):\n            # modalities must match\n            if self.modality_from != other.modality_from:\n                raise ValueError(f\"Mat44 add: modality_from must match, but got {self.modality_from} and {other.modality_from}\")\n            if self.modality_to != other.modality_to:\n                raise ValueError(f\"Mat44 add: modality_from must match, but got {self.modality_to} and {other.modality_to}\")\n            # spaces must match\n            if self.space_from != other.space_from:\n                raise ValueError(f\"Mat44 add: space_from must match, but got {self.space_from} and {other.space_from}\")\n            if self.space_to != other.space_to:\n                raise ValueError(f\"Mat44 add: space_to must match, but got {self.space_to} and {other.space_to}\")\n        return Mat44(self.mat + other.mat, space_from = self.space_from, space_to = self.space_to, modality_from = self.modality_from, modality_to = self.modality_to)\n\n    def __sub__(self, other):\n        if isinstance(other, Mat44):\n            # modalities must match\n            if self.modality_from != other.modality_from:\n                raise ValueError(f\"Mat44 add: modality_from must match, but got {self.modality_from} and {other.modality_from}\")\n            if self.modality_to != other.modality_to:\n                raise ValueError(f\"Mat44 add: modality_from must match, but got {self.modality_to} and {other.modality_to}\")\n            # spaces must match\n            if self.space_from != other.space_from:\n                raise ValueError(f\"Mat44 add: space_from must match, but got {self.space_from} and {other.space_from}\")\n            if self.space_to != other.space_to:\n                raise ValueError(f\"Mat44 add: space_to must match, but got {self.space_to} and {other.space_to}\")\n        return Mat44(self.mat - other.mat, space_from = self.space_from, space_to = self.space_to, modality_from = self.modality_from, modality_to = self.modality_to)\n\n    def __floordiv__(self, other):\n        if isinstance(other, Mat44):\n            # modalities must match\n            if self.modality_from != other.modality_from:\n                raise ValueError(f\"Mat44 add: modality_from must match, but got {self.modality_from} and {other.modality_from}\")\n            if self.modality_to != other.modality_to:\n                raise ValueError(f\"Mat44 add: modality_from must match, but got {self.modality_to} and {other.modality_to}\")\n            # spaces must match\n            if self.space_from != other.space_from:\n                raise ValueError(f\"Mat44 add: space_from must match, but got {self.space_from} and {other.space_from}\")\n            if self.space_to != other.space_to:\n                raise ValueError(f\"Mat44 add: space_to must match, but got {self.space_to} and {other.space_to}\")\n        return Mat44(self.mat // other.mat, space_from = self.space_from, space_to = self.space_to, modality_from = self.modality_from, modality_to = self.modality_to)\n\n    def __mod__(self, other):\n        if isinstance(other, Mat44):\n            # modalities must match\n            if self.modality_from != other.modality_from:\n                raise ValueError(f\"Mat44 add: modality_from must match, but got {self.modality_from} and {other.modality_from}\")\n            if self.modality_to != other.modality_to:\n                raise ValueError(f\"Mat44 add: modality_from must match, but got {self.modality_to} and {other.modality_to}\")\n            # spaces must match\n            if self.space_from != other.space_from:\n                raise ValueError(f\"Mat44 add: space_from must match, but got {self.space_from} and {other.space_from}\")\n            if self.space_to != other.space_to:\n                raise ValueError(f\"Mat44 add: space_to must match, but got {self.space_to} and {other.space_to}\")\n        return Mat44(self.mat % other.mat, space_from = self.space_from, space_to = self.space_to, modality_from = self.modality_from, modality_to = self.modality_to)\n\n    def __pow__(self, other):\n        if isinstance(other, Mat44):\n            # modalities must match\n            if self.modality_from != other.modality_from:\n                raise ValueError(f\"Mat44 add: modality_from must match, but got {self.modality_from} and {other.modality_from}\")\n            if self.modality_to != other.modality_to:\n                raise ValueError(f\"Mat44 add: modality_from must match, but got {self.modality_to} and {other.modality_to}\")\n            # spaces must match\n            if self.space_from != other.space_from:\n                raise ValueError(f\"Mat44 add: space_from must match, but got {self.space_from} and {other.space_from}\")\n            if self.space_to != other.space_to:\n                raise ValueError(f\"Mat44 add: space_to must match, but got {self.space_to} and {other.space_to}\")\n        return Mat44(self.mat ** other.mat, space_from = self.space_from, space_to = self.space_to, modality_from = self.modality_from, modality_to = self.modality_to)\n\n    def __invert__(self):\n        return Mat44(np.linalg.inv(self.mat), space_from = self.space_to, space_to = self.space_from, modality_from = self.modality_to, modality_to = self.modality_from)\n\n    def to_json(self, **kwargs):\n        return json.dumps(np.ndarray.flatten(self.mat).tolist(), **kwargs)\n</code></pre>"},{"location":"api-core-vec3/","title":"<code>&lt;Class Vec3&gt;</code>","text":"<p>Creates a 3D vector with given coordinate space.</p> <p>Parameters:</p> Name Type Description Default <code>x</code> <code>list | tuple | ndarray | float | None</code> <p>x coordinate or a Vec3, or a list/tuple/array of 3 numbers.</p> <code>None</code> <code>y</code> <code>float | None</code> <p>y coordinate or None if x is a Vec3 or a list/tuple/array of 3 numbers.</p> <code>None</code> <code>z</code> <code>float | None</code> <p>z coordinate or None if x is a Vec3 or a list/tuple/array of 3 numbers.</p> <code>None</code> <code>space</code> <code>str | None</code> <p>The space of the vector, either \"ras\", \"ras_tkr\", \"mni305\", \"mni152\" or \"voxel\". </p> <p>This is ignored if x is a Vec3 since the space will be the same as x. In other situations, if space is None, the space will be \"ras\".</p> <code>None</code> Source code in <code>threebrainpy/core/vec3.py</code> <pre><code>class Vec3:\n'''\n    Creates a 3D vector with given coordinate space.\n    Args:\n        x: x coordinate or a Vec3, or a list/tuple/array of 3 numbers.\n        y: y coordinate or None if x is a Vec3 or a list/tuple/array of 3 numbers.\n        z: z coordinate or None if x is a Vec3 or a list/tuple/array of 3 numbers.\n        space: The space of the vector, either \"ras\", \"ras_tkr\", \"mni305\", \"mni152\" or \"voxel\". \n\n            &gt; This is ignored if x is a Vec3 since the space will be the same as x.\n            &gt; In other situations, if space is None, the space will be \"ras\".\n\n    '''\n    def __init__(self, x : list | tuple | np.ndarray | float | None = None, \n                 y : float | None = None, z : float | None = None, space : str | None = None):\n        self.space = \"ras\" if space is None else space\n        if y is None or z is None or isinstance(x, Vec3):\n            if x is None:\n                self._xyz = np.array([ np.nan, np.nan, np.nan, 1.0 ], dtype=float)\n            elif isinstance(x, Vec3):\n                self._xyz = np.array([ x.x, x.y, x.z, 1.0 ], dtype=float)\n                self.space = x.space\n            elif isinstance(x, (list, tuple, np.ndarray)):\n                x = np.array(x, dtype=float).reshape(-1)\n                if x.size in (3, 4, ):\n                    self._xyz = np.array([ x[0], x[1], x[2], 1.0 ], dtype=float)\n                else:\n                    raise ValueError(f\"Vec3 init: x must be a Vec3 or can be converted into Vec3, but got {x}\")\n            elif isinstance(x, (int, float, str)):\n                x = float(x)\n                self._xyz = np.array([ x, x, x, 1.0 ], dtype=float)\n            else:\n                raise ValueError(f\"Vec3 init: x must be a Vec3 or can be converted into float/Vec3, but got {x}\")\n        else:\n            self._xyz = np.array([x, y, z, 1.0], dtype=float)\n\n    @property\n    def x(self):\n'''\n        Get x coordinate.\n        '''\n        return self._xyz[0]\n    @x.setter\n    def x(self, value):\n        self._xyz[0] = value\n\n    @property\n    def y(self):\n'''\n        Get y coordinate.\n        '''\n        return self._xyz[1]\n    @y.setter\n    def y(self, value):\n        self._xyz[1] = value\n\n    @property\n    def z(self):\n'''\n        Get z coordinate.\n        '''\n        return self._xyz[2]\n    @z.setter\n    def z(self, value):\n        self._xyz[2] = value\n\n    def __str__(self):\n        return f\"Vec3({self.x}, {self.y}, {self.z}) [{ self.space }]\"\n\n    def __repr__(self):\n        return str(self)\n\n    def __add__(self, other):\n        if isinstance(other, Vec3):\n            if self.space != other.space:\n                raise ValueError(f\"Vec3 add: spaces must match, but got {self.space} and {other.space}\")\n            return Vec3(self.x + other.x, self.y + other.y, self.z + other.z, space = self.space)\n        else:\n            v = np.array(other, dtype=float)\n            if v.size in (3, 4, ):\n                return Vec3(self.x + v[0], self.y + v[1], self.z + v[2], space = self.space)\n            else:\n                raise ValueError(f\"Vec3 add: other must be a Vec3 or can be converted into Vec3, but got {other}\")\n\n    def __sub__(self, other):\n        if isinstance(other, Vec3):\n            if self.space != other.space:\n                raise ValueError(f\"Vec3 sub: spaces must match, but got {self.space} and {other.space}\")\n            return Vec3(self.x - other.x, self.y - other.y, self.z - other.z, space = self.space)\n        else:\n            v = np.array(other, dtype=float)\n            if v.size in (3, 4, ):\n                return Vec3(self.x - v[0], self.y - v[1], self.z - v[2], space = self.space)\n            else:\n                raise ValueError(f\"Vec3 sub: other must be a Vec3 or can be converted into Vec3, but got {other}\")\n\n    def __mul__(self, other):\n        if isinstance(other, Vec3):\n            if self.space != other.space:\n                raise ValueError(f\"Vec3 mul: spaces must match, but got {self.space} and {other.space}\")\n            return Vec3(self.x * other.x, self.y * other.y, self.z * other.z, space = self.space)\n        else:\n            v = np.array(other, dtype=float)\n            if v.size in (3, 4, ):\n                return Vec3(self.x * v[0], self.y * v[1], self.z * v[2], space = self.space)\n            else:\n                raise ValueError(f\"Vec3 mul: other must be a Vec3 or can be converted into Vec3, but got {other}\")\n\n    def __truediv__(self, other):\n        if isinstance(other, Vec3):\n            if self.space != other.space:\n                raise ValueError(f\"Vec3 truediv: spaces must match, but got {self.space} and {other.space}\")\n            return Vec3(self.x / other.x, self.y / other.y, self.z / other.z, space = self.space)\n        else:\n            v = np.array(other, dtype=float)\n            if v.size == 3 in (3, 4, ):\n                return Vec3(self.x / v[0], self.y / v[1], self.z / v[2], space = self.space)\n            else:\n                raise ValueError(f\"Vec3 truediv: other must be a Vec3 or can be converted into Vec3, but got {other}\")\n\n    def __floordiv__(self, other):\n        if isinstance(other, Vec3):\n            if self.space != other.space:\n                raise ValueError(f\"Vec3 floordiv: spaces must match, but got {self.space} and {other.space}\")\n            return Vec3(self.x // other.x, self.y // other.y, self.z // other.z, space = self.space)\n        else:\n            v = np.array(other, dtype=float)\n            if v.size in (3, 4, ):\n                return Vec3(self.x // v[0], self.y // v[1], self.z // v[2], space = self.space)\n            else:\n                raise ValueError(f\"Vec3 floordiv: other must be a Vec3 or can be converted into Vec3, but got {other}\")\n\n    def to_list(self):\n'''\n        Convert this vector into a list of 3 numbers.\n        When the point is invalid, a list of 3 `9999.0` will be returned. \n        Points that far will be be rendered in the viewer\n        '''\n        if not np.isfinite(self.length()):\n            return [9999.0, 9999.0, 9999.0]\n        return [self.x, self.y, self.z]\n\n    def to_tuple(self):\n'''\n        Convert this vector into a tuple of 3 numbers.\n        '''\n        return tuple(self._xyz[:3])\n\n    def copyFrom(self, other):\n'''\n        Copy (in-place) the value of this vector from another vector or a list/tuple/array of 3 numbers.\n        Args:\n            other Vec3 | list | tuple | np.ndarray : The other vector or a list/tuple/array of 3 numbers.\n        '''\n        if isinstance(other, Vec3):\n            self.space = other.space\n            other = other._xyz\n        else:\n            other = np.array(other, dtype=float)\n            if other.size not in (3, 4, ):\n                raise ValueError(f\"Vec3 copyFrom: other must be a Vec3 or can be converted into Vec3, but got {other}\")\n        self._xyz[0] = other[0]\n        self._xyz[1] = other[1]\n        self._xyz[2] = other[2]\n        return self\n\n    def applyMat44(self, mat44 : Mat44):\n'''\n        Apply a 4x4 matrix to this vector in-place.\n        Args:\n            mat44: A 4x4 matrix \n        '''\n        if isinstance(mat44, Mat44):\n            if self.space != mat44.space_from:\n                raise ValueError(f\"Vec3 applyMatrix44: spaces must match, but got {self.space} and {mat44.space_from}\")\n            self.copyFrom(np.dot(mat44.mat, self._xyz))\n            self.space = mat44.space_to\n        else:\n            raise ValueError(f\"Vec3 applyMatrix44: mat44 must be a Mat44, but got {mat44}\")\n        return self\n\n    def add(self, vec3):\n'''\n        Add another vector to this vector in-place.\n        Args:\n            vec3 Vec3: Another vector.\n        '''\n        if isinstance(vec3, Vec3):\n            if self.space != vec3.space:\n                raise ValueError(f\"Vec3 add: spaces must match, but got {self.space} and {vec3.space}\")\n            self._xyz[0] += vec3._xyz[0]\n            self._xyz[1] += vec3._xyz[1]\n            self._xyz[2] += vec3._xyz[2]\n        else:\n            raise ValueError(f\"Vec3 add: vec3 must be a Vec3, but got {vec3}\")\n        return self\n\n    def sub(self, vec3):\n'''\n        Subtract another vector to this vector in-place.\n        Args:\n            vec3 Vec3: Another vector.\n        '''\n        if isinstance(vec3, Vec3):\n            if self.space != vec3.space:\n                raise ValueError(f\"Vec3 sub: spaces must match, but got {self.space} and {vec3.space}\")\n            self._xyz[0] -= vec3._xyz[0]\n            self._xyz[1] -= vec3._xyz[1]\n            self._xyz[2] -= vec3._xyz[2]\n        else:\n            raise ValueError(f\"Vec3 sub: vec3 must be a Vec3, but got {vec3}\")\n        return self\n\n    def dot(self, vec3) -&gt; float:\n'''\n        Dot-product another vector to this vector.\n        Args:\n            vec3 Vec3: Another vector.\n        Returns:\n            float: The dot product of this vector and the other vector.\n        '''\n        if isinstance(vec3, Vec3):\n            if self.space != vec3.space:\n                raise ValueError(f\"Vec3 dot: spaces must match, but got {self.space} and {vec3.space}\")\n            return self._xyz[0] * vec3._xyz[0] + self._xyz[1] * vec3._xyz[1] + self._xyz[2] * vec3._xyz[2]\n        else:\n            raise ValueError(f\"Vec3 dot: vec3 must be a Vec3, but got {vec3}\")\n\n    def multiplyScalar(self, scalar):\n'''\n        Multiply this vector by a scalar in-place.\n        Args:\n            scalar float: A scalar.\n        '''\n        self._xyz[0] *= scalar\n        self._xyz[1] *= scalar\n        self._xyz[2] *= scalar\n        return self\n\n    # def cross(self, vec3):\n    #     if isinstance(vec3, Vec3):\n    #         if self.space != vec3.space:\n    #             raise ValueError(f\"Vec3 cross: spaces must match, but got {self.space} and {vec3.space}\")\n    #         return Vec3(\n    #             self._xyz[1] * vec3._xyz[2] - self._xyz[2] * vec3._xyz[1],\n    #             self._xyz[2] * vec3._xyz[0] - self._xyz[0] * vec3._xyz[2],\n    #             self._xyz[0] * vec3._xyz[1] - self._xyz[1] * vec3._xyz[0],\n    #             space = self.space\n    #         )\n    #     else:\n    #         raise ValueError(f\"Vec3 cross: vec3 must be a Vec3, but got {vec3}\")\n    #     return self\n\n    def length(self) -&gt; float:\n'''\n        Get the length of this vector.\n        Returns:\n            float: The length of this vector.\n        '''\n        return np.sqrt(self._xyz[0] * self._xyz[0] + self._xyz[1] * self._xyz[1] + self._xyz[2] * self._xyz[2])\n\n    def normalize(self):\n'''\n        Normalize this vector in-place.\n        '''\n        l = self.length()\n        if l == 0.0:\n            return self\n        self._xyz[0] /= l\n        self._xyz[1] /= l\n        self._xyz[2] /= l\n        return self\n\n    def distanceTo(self, vec3) -&gt; float:\n'''\n        Calculate the distance to another vector.\n        Args:\n            vec3 Vec3: Another vector.\n        Returns:\n            float: The L2 distance to the other vector.\n        '''\n        if isinstance(vec3, Vec3):\n            if self.space != vec3.space:\n                raise ValueError(f\"Vec3 distanceTo: spaces must match, but got {self.space} and {vec3.space}\")\n            return np.sqrt(\n                (self._xyz[0] - vec3._xyz[0]) * (self._xyz[0] - vec3._xyz[0]) +\n                (self._xyz[1] - vec3._xyz[1]) * (self._xyz[1] - vec3._xyz[1]) +\n                (self._xyz[2] - vec3._xyz[2]) * (self._xyz[2] - vec3._xyz[2])\n            )\n        else:\n            raise ValueError(f\"Vec3 distanceTo: vec3 must be a Vec3, but got {vec3}\")\n\n    def distanceToSquared(self, vec3) -&gt; float:\n'''\n        Calculate the squared distance to another vector.\n        Args:\n            vec3 Vec3: Another vector.\n        Returns:\n            float: The squared L2 distance to the other vector.\n        '''\n        if isinstance(vec3, Vec3):\n            if self.space != vec3.space:\n                raise ValueError(f\"Vec3 distanceToSquared: spaces must match, but got {self.space} and {vec3.space}\")\n            return (\n                (self._xyz[0] - vec3._xyz[0]) * (self._xyz[0] - vec3._xyz[0]) +\n                (self._xyz[1] - vec3._xyz[1]) * (self._xyz[1] - vec3._xyz[1]) +\n                (self._xyz[2] - vec3._xyz[2]) * (self._xyz[2] - vec3._xyz[2])\n            )\n        else:\n            raise ValueError(f\"Vec3 distanceToSquared: vec3 must be a Vec3, but got {vec3}\")\n\n    def set(self, x : float, y : float, z : float):\n'''\n        Set the value of this vector in-place.\n        Args:\n            x: x coordinate.\n            y: y coordinate.\n            z: z coordinate.\n        '''\n        self._xyz[0] = x\n        self._xyz[1] = y\n        self._xyz[2] = z\n        return self\n\n    def __copy__(self):\n        return Vec3(self._xyz[0], self._xyz[1], self._xyz[2], space = self.space)\n\n    def copy(self):\n'''\n        A deep copy this vector.\n        '''\n        return self.__copy__()\n</code></pre> <p>             Bases: <code>object</code></p> <p>A 4x4 matrix for 3D affine transformation.</p> <p>Parameters:</p> Name Type Description Default <code>mat</code> <code>ndarray | list | tuple | None</code> <p>The matrix, can be a 1D array of length 12 or 16, or a 2D array of shape (3,4) or (4,4).</p> <code>None</code> <code>byrow</code> <code>bool</code> <p>Whether the matrix is in row-major order (default) or column-major order.</p> <code>True</code> <code>space_from</code> <code>str</code> <p>The space from which the matrix is defined, choices are \"ras\", \"voxel\", \"ras_tkr\", \"mni305\", \"mni152\".</p> <ul> <li>\"ras\": scanner-RAS space</li> <li>\"voxel\": voxel indexing space (or IJK space)</li> <li>\"ras_tkr\": FreeSurfer RAS space, this is the space used internally by the viewer engine in JavaScript</li> <li>\"mni305\": MNI305 template space</li> <li>\"mni152\": MNI152 template space</li> </ul> <p>threebrainpy does not limit the choices, but the viewer only supports these spaces.</p> <code>'ras'</code> <code>space_to</code> <code>str</code> <p>The space to which the matrix is defined, choices are the same as <code>space_from</code>.</p> <code>'ras'</code> <code>modality_from</code> <code>str</code> <p>The imaging modality from which the matrix is defined, choices are \"T1\" or \"CT\" other modalities may be  added in the future, default is \"T1\".</p> <code>'T1'</code> <code>modality_to</code> <code>str</code> <p>The imaging modality to which the matrix is defined. If set to <code>None</code>, then it will be set with the same value as <code>modality_from</code> automatically; default choice is <code>None</code>.</p> <code>'T1'</code> <p>Examples:</p> <pre><code>&gt;&gt;&gt; Mat44([1,2,3,4,5,6,7,8,9,10,11,12])\nMat44 (T1.ras -&gt; T1.ras): \narray([[ 1.,  2.,  3.,  4.],\n    [ 5.,  6.,  7.,  8.],\n    [ 9., 10., 11., 12.],\n    [ 0.,  0.,  0.,  1.]])\n&gt;&gt;&gt; Mat44([1,2,3,4,5,6,7,8,9,10,11,12], byrow=False)\nMat44 (T1.ras -&gt; T1.ras): \narray([[ 1.,  4.,  7., 10.],\n    [ 2.,  5.,  8., 11.],\n    [ 3.,  6.,  9., 12.],\n    [ 0.,  0.,  0.,  1.]])\n&gt;&gt;&gt; Mat44([-1,0,0,128,0,0,1,-128,0,-1,0,128], space_from=\"voxel\", space_to=\"ras_tkr\")\nMat44 (T1.voxel -&gt; T1.ras_tkr): \narray([[  -1.,    0.,    0.,  128.],\n    [   0.,    0.,    1., -128.],\n    [   0.,   -1.,    0.,  128.],\n    [   0.,    0.,    0.,    1.]])\n</code></pre> Source code in <code>threebrainpy/core/mat44.py</code> <pre><code>class Mat44(object):\n'''\n    A 4x4 matrix for 3D affine transformation.\n    Args:\n        mat: The matrix, can be a 1D array of length 12 or 16, or a 2D array of shape (3,4) or (4,4).\n        byrow: Whether the matrix is in row-major order (default) or column-major order.\n        space_from: The space from which the matrix is defined, choices are \"ras\", \"voxel\", \"ras_tkr\", \"mni305\", \"mni152\".\n\n            * \"ras\": scanner-RAS space\n            * \"voxel\": voxel indexing space (or IJK space)\n            * \"ras_tkr\": FreeSurfer RAS space, this is the space used internally by the viewer engine in JavaScript\n            * \"mni305\": MNI305 template space\n            * \"mni152\": MNI152 template space\n\n            &gt; threebrainpy does not limit the choices, but the viewer only supports these spaces.\n\n        space_to: The space to which the matrix is defined, choices are the same as `space_from`.\n        modality_from: The imaging modality from which the matrix is defined, choices are \"T1\" or \"CT\" other modalities may be \n            added in the future, default is \"T1\".\n        modality_to: The imaging modality to which the matrix is defined. If set to `None`, then it will be set\n            with the same value as `modality_from` automatically; default choice is `None`.\n\n    Examples:\n\n        &gt;&gt;&gt; Mat44([1,2,3,4,5,6,7,8,9,10,11,12])\n        Mat44 (T1.ras -&gt; T1.ras): \n        array([[ 1.,  2.,  3.,  4.],\n            [ 5.,  6.,  7.,  8.],\n            [ 9., 10., 11., 12.],\n            [ 0.,  0.,  0.,  1.]])\n        &gt;&gt;&gt; Mat44([1,2,3,4,5,6,7,8,9,10,11,12], byrow=False)\n        Mat44 (T1.ras -&gt; T1.ras): \n        array([[ 1.,  4.,  7., 10.],\n            [ 2.,  5.,  8., 11.],\n            [ 3.,  6.,  9., 12.],\n            [ 0.,  0.,  0.,  1.]])\n        &gt;&gt;&gt; Mat44([-1,0,0,128,0,0,1,-128,0,-1,0,128], space_from=\"voxel\", space_to=\"ras_tkr\")\n        Mat44 (T1.voxel -&gt; T1.ras_tkr): \n        array([[  -1.,    0.,    0.,  128.],\n            [   0.,    0.,    1., -128.],\n            [   0.,   -1.,    0.,  128.],\n            [   0.,    0.,    0.,    1.]])\n    '''\n    def __init__(self, mat : np.ndarray | list | tuple | None = None, byrow : bool = True, \n                 space_from : str = 'ras', space_to : str = 'ras', \n                 modality_from : str = \"T1\", modality_to : str = \"T1\"):\n        if mat is None:\n            self.mat = np.eye(4)\n        else:\n            mat = np.array(mat, copy = True, dtype=float)\n            if mat.size == 12:\n                if byrow:\n                    mat = mat.reshape(3,4)\n                else:\n                    mat = mat.reshape(4,3).transpose()\n                map = np.append(mat, [[0,0,0,1]], axis=0)\n            else:\n                map = mat.reshape(4, 4)\n                if not byrow:\n                    mat = mat.transpose()\n            self.mat = map\n        self.space_from = space_from\n        self.space_to = space_to\n        self.modality_from = modality_from\n        self.modality_to = modality_from if modality_to is None else modality_to\n        self.extra = {}\n\n    def __mul__(self, other):\n        if isinstance(other, Mat44):\n            # modalities must match\n            if self.modality_from != other.modality_to:\n                raise ValueError(f\"Mat44 multiply: modalities must match, but got {self.modality_from} and {other.modality_to}\")\n            # spaces must match\n            if self.space_from != other.space_to:\n                raise ValueError(f\"Mat44 multiply: spaces must match, but got {self.space_from} and {other.space_to}\")\n        return Mat44(np.matmul(self.mat, other.mat), modality_from=other.modality_from, modality_to=self.modality_to, space_from=other.space_from, space_to=self.space_to)\n\n    def __repr__(self):\n        re = repr(self.mat)\n        return f\"Mat44 ({self.modality_from}.{self.space_from} -&gt; {self.modality_to}.{self.space_to}): \\n{ re }\"\n\n    def __str__(self):\n        return str(self.mat)\n\n    def __getitem__(self, key):\n        return self.mat[key]\n\n    def __setitem__(self, key, value):\n        self.mat[key] = value\n\n    def __eq__(self, other):\n        return np.allclose(self.mat, other.mat)\n\n    def __ne__(self, other):\n        return not np.allclose(self.mat, other.mat)\n\n    def __hash__(self):\n        return hash(str(self.mat))\n\n    def __copy__(self):\n        return Mat44(self.mat.copy(), space_from = self.space_from, space_to = self.space_to, modality_from = self.modality_from, modality_to = self.modality_to)\n\n    def __deepcopy__(self, memo):\n        return Mat44(self.mat.copy(), space_from = self.space_from, space_to = self.space_to, modality_from = self.modality_from, modality_to = self.modality_to)\n\n    def __iter__(self):\n        return iter(self.mat)\n\n    def __len__(self):\n        return len(self.mat)\n\n    def __abs__(self):\n        return abs(self.mat)\n\n    def __neg__(self):\n        return Mat44(-self.mat, space_from = self.space_from, space_to = self.space_to, modality_from = self.modality_from, modality_to = self.modality_to)\n\n    def __pos__(self):\n        return Mat44(+self.mat, space_from = self.space_from, space_to = self.space_to, modality_from = self.modality_from, modality_to = self.modality_to)\n\n    def __add__(self, other):\n        if isinstance(other, Mat44):\n            # modalities must match\n            if self.modality_from != other.modality_from:\n                raise ValueError(f\"Mat44 add: modality_from must match, but got {self.modality_from} and {other.modality_from}\")\n            if self.modality_to != other.modality_to:\n                raise ValueError(f\"Mat44 add: modality_from must match, but got {self.modality_to} and {other.modality_to}\")\n            # spaces must match\n            if self.space_from != other.space_from:\n                raise ValueError(f\"Mat44 add: space_from must match, but got {self.space_from} and {other.space_from}\")\n            if self.space_to != other.space_to:\n                raise ValueError(f\"Mat44 add: space_to must match, but got {self.space_to} and {other.space_to}\")\n        return Mat44(self.mat + other.mat, space_from = self.space_from, space_to = self.space_to, modality_from = self.modality_from, modality_to = self.modality_to)\n\n    def __sub__(self, other):\n        if isinstance(other, Mat44):\n            # modalities must match\n            if self.modality_from != other.modality_from:\n                raise ValueError(f\"Mat44 add: modality_from must match, but got {self.modality_from} and {other.modality_from}\")\n            if self.modality_to != other.modality_to:\n                raise ValueError(f\"Mat44 add: modality_from must match, but got {self.modality_to} and {other.modality_to}\")\n            # spaces must match\n            if self.space_from != other.space_from:\n                raise ValueError(f\"Mat44 add: space_from must match, but got {self.space_from} and {other.space_from}\")\n            if self.space_to != other.space_to:\n                raise ValueError(f\"Mat44 add: space_to must match, but got {self.space_to} and {other.space_to}\")\n        return Mat44(self.mat - other.mat, space_from = self.space_from, space_to = self.space_to, modality_from = self.modality_from, modality_to = self.modality_to)\n\n    def __floordiv__(self, other):\n        if isinstance(other, Mat44):\n            # modalities must match\n            if self.modality_from != other.modality_from:\n                raise ValueError(f\"Mat44 add: modality_from must match, but got {self.modality_from} and {other.modality_from}\")\n            if self.modality_to != other.modality_to:\n                raise ValueError(f\"Mat44 add: modality_from must match, but got {self.modality_to} and {other.modality_to}\")\n            # spaces must match\n            if self.space_from != other.space_from:\n                raise ValueError(f\"Mat44 add: space_from must match, but got {self.space_from} and {other.space_from}\")\n            if self.space_to != other.space_to:\n                raise ValueError(f\"Mat44 add: space_to must match, but got {self.space_to} and {other.space_to}\")\n        return Mat44(self.mat // other.mat, space_from = self.space_from, space_to = self.space_to, modality_from = self.modality_from, modality_to = self.modality_to)\n\n    def __mod__(self, other):\n        if isinstance(other, Mat44):\n            # modalities must match\n            if self.modality_from != other.modality_from:\n                raise ValueError(f\"Mat44 add: modality_from must match, but got {self.modality_from} and {other.modality_from}\")\n            if self.modality_to != other.modality_to:\n                raise ValueError(f\"Mat44 add: modality_from must match, but got {self.modality_to} and {other.modality_to}\")\n            # spaces must match\n            if self.space_from != other.space_from:\n                raise ValueError(f\"Mat44 add: space_from must match, but got {self.space_from} and {other.space_from}\")\n            if self.space_to != other.space_to:\n                raise ValueError(f\"Mat44 add: space_to must match, but got {self.space_to} and {other.space_to}\")\n        return Mat44(self.mat % other.mat, space_from = self.space_from, space_to = self.space_to, modality_from = self.modality_from, modality_to = self.modality_to)\n\n    def __pow__(self, other):\n        if isinstance(other, Mat44):\n            # modalities must match\n            if self.modality_from != other.modality_from:\n                raise ValueError(f\"Mat44 add: modality_from must match, but got {self.modality_from} and {other.modality_from}\")\n            if self.modality_to != other.modality_to:\n                raise ValueError(f\"Mat44 add: modality_from must match, but got {self.modality_to} and {other.modality_to}\")\n            # spaces must match\n            if self.space_from != other.space_from:\n                raise ValueError(f\"Mat44 add: space_from must match, but got {self.space_from} and {other.space_from}\")\n            if self.space_to != other.space_to:\n                raise ValueError(f\"Mat44 add: space_to must match, but got {self.space_to} and {other.space_to}\")\n        return Mat44(self.mat ** other.mat, space_from = self.space_from, space_to = self.space_to, modality_from = self.modality_from, modality_to = self.modality_to)\n\n    def __invert__(self):\n        return Mat44(np.linalg.inv(self.mat), space_from = self.space_to, space_to = self.space_from, modality_from = self.modality_to, modality_to = self.modality_from)\n\n    def to_json(self, **kwargs):\n        return json.dumps(np.ndarray.flatten(self.mat).tolist(), **kwargs)\n</code></pre>"},{"location":"api-core-vec3/#threebrainpy.core.vec3.Vec3.x","title":"<code>x</code>  <code>property</code> <code>writable</code>","text":"<p>Get x coordinate.</p>"},{"location":"api-core-vec3/#threebrainpy.core.vec3.Vec3.y","title":"<code>y</code>  <code>property</code> <code>writable</code>","text":"<p>Get y coordinate.</p>"},{"location":"api-core-vec3/#threebrainpy.core.vec3.Vec3.z","title":"<code>z</code>  <code>property</code> <code>writable</code>","text":"<p>Get z coordinate.</p>"},{"location":"api-core-vec3/#threebrainpy.core.vec3.Vec3.add","title":"<code>add(vec3)</code>","text":"<p>Add another vector to this vector in-place.</p> <p>Parameters:</p> Name Type Description Default <code>vec3</code> <code>Vec3</code> <p>Another vector.</p> required Source code in <code>threebrainpy/core/vec3.py</code> <pre><code>def add(self, vec3):\n'''\n    Add another vector to this vector in-place.\n    Args:\n        vec3 Vec3: Another vector.\n    '''\n    if isinstance(vec3, Vec3):\n        if self.space != vec3.space:\n            raise ValueError(f\"Vec3 add: spaces must match, but got {self.space} and {vec3.space}\")\n        self._xyz[0] += vec3._xyz[0]\n        self._xyz[1] += vec3._xyz[1]\n        self._xyz[2] += vec3._xyz[2]\n    else:\n        raise ValueError(f\"Vec3 add: vec3 must be a Vec3, but got {vec3}\")\n    return self\n</code></pre>"},{"location":"api-core-vec3/#threebrainpy.core.vec3.Vec3.applyMat44","title":"<code>applyMat44(mat44)</code>","text":"<p>Apply a 4x4 matrix to this vector in-place.</p> <p>Parameters:</p> Name Type Description Default <code>mat44</code> <code>Mat44</code> <p>A 4x4 matrix</p> required Source code in <code>threebrainpy/core/vec3.py</code> <pre><code>def applyMat44(self, mat44 : Mat44):\n'''\n    Apply a 4x4 matrix to this vector in-place.\n    Args:\n        mat44: A 4x4 matrix \n    '''\n    if isinstance(mat44, Mat44):\n        if self.space != mat44.space_from:\n            raise ValueError(f\"Vec3 applyMatrix44: spaces must match, but got {self.space} and {mat44.space_from}\")\n        self.copyFrom(np.dot(mat44.mat, self._xyz))\n        self.space = mat44.space_to\n    else:\n        raise ValueError(f\"Vec3 applyMatrix44: mat44 must be a Mat44, but got {mat44}\")\n    return self\n</code></pre>"},{"location":"api-core-vec3/#threebrainpy.core.vec3.Vec3.copy","title":"<code>copy()</code>","text":"<p>A deep copy this vector.</p> Source code in <code>threebrainpy/core/vec3.py</code> <pre><code>def copy(self):\n'''\n    A deep copy this vector.\n    '''\n    return self.__copy__()\n</code></pre>"},{"location":"api-core-vec3/#threebrainpy.core.vec3.Vec3.copyFrom","title":"<code>copyFrom(other)</code>","text":"<p>Copy (in-place) the value of this vector from another vector or a list/tuple/array of 3 numbers.</p> <p>Parameters:</p> Name Type Description Default <code>other</code> <code>Vec3 | list | tuple | ndarray</code> <p>The other vector or a list/tuple/array of 3 numbers.</p> required Source code in <code>threebrainpy/core/vec3.py</code> <pre><code>def copyFrom(self, other):\n'''\n    Copy (in-place) the value of this vector from another vector or a list/tuple/array of 3 numbers.\n    Args:\n        other Vec3 | list | tuple | np.ndarray : The other vector or a list/tuple/array of 3 numbers.\n    '''\n    if isinstance(other, Vec3):\n        self.space = other.space\n        other = other._xyz\n    else:\n        other = np.array(other, dtype=float)\n        if other.size not in (3, 4, ):\n            raise ValueError(f\"Vec3 copyFrom: other must be a Vec3 or can be converted into Vec3, but got {other}\")\n    self._xyz[0] = other[0]\n    self._xyz[1] = other[1]\n    self._xyz[2] = other[2]\n    return self\n</code></pre>"},{"location":"api-core-vec3/#threebrainpy.core.vec3.Vec3.distanceTo","title":"<code>distanceTo(vec3)</code>","text":"<p>Calculate the distance to another vector.</p> <p>Parameters:</p> Name Type Description Default <code>vec3</code> <code>Vec3</code> <p>Another vector.</p> required <p>Returns:</p> Name Type Description <code>float</code> <code>float</code> <p>The L2 distance to the other vector.</p> Source code in <code>threebrainpy/core/vec3.py</code> <pre><code>def distanceTo(self, vec3) -&gt; float:\n'''\n    Calculate the distance to another vector.\n    Args:\n        vec3 Vec3: Another vector.\n    Returns:\n        float: The L2 distance to the other vector.\n    '''\n    if isinstance(vec3, Vec3):\n        if self.space != vec3.space:\n            raise ValueError(f\"Vec3 distanceTo: spaces must match, but got {self.space} and {vec3.space}\")\n        return np.sqrt(\n            (self._xyz[0] - vec3._xyz[0]) * (self._xyz[0] - vec3._xyz[0]) +\n            (self._xyz[1] - vec3._xyz[1]) * (self._xyz[1] - vec3._xyz[1]) +\n            (self._xyz[2] - vec3._xyz[2]) * (self._xyz[2] - vec3._xyz[2])\n        )\n    else:\n        raise ValueError(f\"Vec3 distanceTo: vec3 must be a Vec3, but got {vec3}\")\n</code></pre>"},{"location":"api-core-vec3/#threebrainpy.core.vec3.Vec3.distanceToSquared","title":"<code>distanceToSquared(vec3)</code>","text":"<p>Calculate the squared distance to another vector.</p> <p>Parameters:</p> Name Type Description Default <code>vec3</code> <code>Vec3</code> <p>Another vector.</p> required <p>Returns:</p> Name Type Description <code>float</code> <code>float</code> <p>The squared L2 distance to the other vector.</p> Source code in <code>threebrainpy/core/vec3.py</code> <pre><code>def distanceToSquared(self, vec3) -&gt; float:\n'''\n    Calculate the squared distance to another vector.\n    Args:\n        vec3 Vec3: Another vector.\n    Returns:\n        float: The squared L2 distance to the other vector.\n    '''\n    if isinstance(vec3, Vec3):\n        if self.space != vec3.space:\n            raise ValueError(f\"Vec3 distanceToSquared: spaces must match, but got {self.space} and {vec3.space}\")\n        return (\n            (self._xyz[0] - vec3._xyz[0]) * (self._xyz[0] - vec3._xyz[0]) +\n            (self._xyz[1] - vec3._xyz[1]) * (self._xyz[1] - vec3._xyz[1]) +\n            (self._xyz[2] - vec3._xyz[2]) * (self._xyz[2] - vec3._xyz[2])\n        )\n    else:\n        raise ValueError(f\"Vec3 distanceToSquared: vec3 must be a Vec3, but got {vec3}\")\n</code></pre>"},{"location":"api-core-vec3/#threebrainpy.core.vec3.Vec3.dot","title":"<code>dot(vec3)</code>","text":"<p>Dot-product another vector to this vector.</p> <p>Parameters:</p> Name Type Description Default <code>vec3</code> <code>Vec3</code> <p>Another vector.</p> required <p>Returns:</p> Name Type Description <code>float</code> <code>float</code> <p>The dot product of this vector and the other vector.</p> Source code in <code>threebrainpy/core/vec3.py</code> <pre><code>def dot(self, vec3) -&gt; float:\n'''\n    Dot-product another vector to this vector.\n    Args:\n        vec3 Vec3: Another vector.\n    Returns:\n        float: The dot product of this vector and the other vector.\n    '''\n    if isinstance(vec3, Vec3):\n        if self.space != vec3.space:\n            raise ValueError(f\"Vec3 dot: spaces must match, but got {self.space} and {vec3.space}\")\n        return self._xyz[0] * vec3._xyz[0] + self._xyz[1] * vec3._xyz[1] + self._xyz[2] * vec3._xyz[2]\n    else:\n        raise ValueError(f\"Vec3 dot: vec3 must be a Vec3, but got {vec3}\")\n</code></pre>"},{"location":"api-core-vec3/#threebrainpy.core.vec3.Vec3.length","title":"<code>length()</code>","text":"<p>Get the length of this vector.</p> <p>Returns:</p> Name Type Description <code>float</code> <code>float</code> <p>The length of this vector.</p> Source code in <code>threebrainpy/core/vec3.py</code> <pre><code>def length(self) -&gt; float:\n'''\n    Get the length of this vector.\n    Returns:\n        float: The length of this vector.\n    '''\n    return np.sqrt(self._xyz[0] * self._xyz[0] + self._xyz[1] * self._xyz[1] + self._xyz[2] * self._xyz[2])\n</code></pre>"},{"location":"api-core-vec3/#threebrainpy.core.vec3.Vec3.multiplyScalar","title":"<code>multiplyScalar(scalar)</code>","text":"<p>Multiply this vector by a scalar in-place.</p> <p>Parameters:</p> Name Type Description Default <code>scalar</code> <code>float</code> <p>A scalar.</p> required Source code in <code>threebrainpy/core/vec3.py</code> <pre><code>def multiplyScalar(self, scalar):\n'''\n    Multiply this vector by a scalar in-place.\n    Args:\n        scalar float: A scalar.\n    '''\n    self._xyz[0] *= scalar\n    self._xyz[1] *= scalar\n    self._xyz[2] *= scalar\n    return self\n</code></pre>"},{"location":"api-core-vec3/#threebrainpy.core.vec3.Vec3.normalize","title":"<code>normalize()</code>","text":"<p>Normalize this vector in-place.</p> Source code in <code>threebrainpy/core/vec3.py</code> <pre><code>def normalize(self):\n'''\n    Normalize this vector in-place.\n    '''\n    l = self.length()\n    if l == 0.0:\n        return self\n    self._xyz[0] /= l\n    self._xyz[1] /= l\n    self._xyz[2] /= l\n    return self\n</code></pre>"},{"location":"api-core-vec3/#threebrainpy.core.vec3.Vec3.set","title":"<code>set(x, y, z)</code>","text":"<p>Set the value of this vector in-place.</p> <p>Parameters:</p> Name Type Description Default <code>x</code> <code>float</code> <p>x coordinate.</p> required <code>y</code> <code>float</code> <p>y coordinate.</p> required <code>z</code> <code>float</code> <p>z coordinate.</p> required Source code in <code>threebrainpy/core/vec3.py</code> <pre><code>def set(self, x : float, y : float, z : float):\n'''\n    Set the value of this vector in-place.\n    Args:\n        x: x coordinate.\n        y: y coordinate.\n        z: z coordinate.\n    '''\n    self._xyz[0] = x\n    self._xyz[1] = y\n    self._xyz[2] = z\n    return self\n</code></pre>"},{"location":"api-core-vec3/#threebrainpy.core.vec3.Vec3.sub","title":"<code>sub(vec3)</code>","text":"<p>Subtract another vector to this vector in-place.</p> <p>Parameters:</p> Name Type Description Default <code>vec3</code> <code>Vec3</code> <p>Another vector.</p> required Source code in <code>threebrainpy/core/vec3.py</code> <pre><code>def sub(self, vec3):\n'''\n    Subtract another vector to this vector in-place.\n    Args:\n        vec3 Vec3: Another vector.\n    '''\n    if isinstance(vec3, Vec3):\n        if self.space != vec3.space:\n            raise ValueError(f\"Vec3 sub: spaces must match, but got {self.space} and {vec3.space}\")\n        self._xyz[0] -= vec3._xyz[0]\n        self._xyz[1] -= vec3._xyz[1]\n        self._xyz[2] -= vec3._xyz[2]\n    else:\n        raise ValueError(f\"Vec3 sub: vec3 must be a Vec3, but got {vec3}\")\n    return self\n</code></pre>"},{"location":"api-core-vec3/#threebrainpy.core.vec3.Vec3.to_list","title":"<code>to_list()</code>","text":"<p>Convert this vector into a list of 3 numbers. When the point is invalid, a list of 3 <code>9999.0</code> will be returned.  Points that far will be be rendered in the viewer</p> Source code in <code>threebrainpy/core/vec3.py</code> <pre><code>def to_list(self):\n'''\n    Convert this vector into a list of 3 numbers.\n    When the point is invalid, a list of 3 `9999.0` will be returned. \n    Points that far will be be rendered in the viewer\n    '''\n    if not np.isfinite(self.length()):\n        return [9999.0, 9999.0, 9999.0]\n    return [self.x, self.y, self.z]\n</code></pre>"},{"location":"api-core-vec3/#threebrainpy.core.vec3.Vec3.to_tuple","title":"<code>to_tuple()</code>","text":"<p>Convert this vector into a tuple of 3 numbers.</p> Source code in <code>threebrainpy/core/vec3.py</code> <pre><code>def to_tuple(self):\n'''\n    Convert this vector into a tuple of 3 numbers.\n    '''\n    return tuple(self._xyz[:3])\n</code></pre>"},{"location":"api-utils/","title":"Module utils","text":""},{"location":"api-utils/#threebrainpy.utils.VolumeWrapper","title":"<code>VolumeWrapper</code>","text":"Source code in <code>threebrainpy/utils/volume.py</code> <pre><code>class VolumeWrapper():\n    def __init__(self, volume, **kwargs) -&gt; None:\n'''\n        Create a volume wrapper. The volume must be either NIFTI or FreeSurfer (mgh/mgz) format.\n        @param volume: The volume to be wrapped. It can be either a file path or one of the followings:\n            1. nibabel.Nifti1Image\n            2. nibabel.Nifti2Image\n            3. nibabel.MGHImage\n        '''\n        if isinstance(volume, str):\n            volume = read_volume(volume, **kwargs)\n        self._volume = volume\n        # make sure the volume is in the correct format\n        if isinstance(volume, (nibabel.Nifti1Image, nibabel.Nifti2Image)):\n            self._format = \"nii\"\n        elif isinstance(volume, (nibabel.MGHImage)):\n            self._format = \"mgz\"\n        else:\n            raise ValueError(f\"Unsupported volume type: {type(volume)}. Please make sure this is a valid NIFTI or FreeSurfer volume.\")\n        pass\n    @property\n    def volume(self):\n        return self._volume\n    @property\n    def format(self):\n        return self._format\n    @property\n    def header(self):\n        return self._volume.header\n    @property\n    def shape(self):\n        return self._volume.shape\n    @property\n    def ndim(self):\n        return self._volume.ndim\n    @property\n    def vox2ras(self) -&gt; Mat44:\n        return self.get_vox2ras()\n    @property\n    def vox2ras_tkr(self) -&gt; Mat44:\n        return self.get_vox2ras_tkr()\n    def get_vox2ras(self):\n        m = Mat44(self._volume.affine, space_from=\"voxel\", space_to=\"ras\")\n        return m\n    def get_vox2ras_tkr(self):\n        if self._format == \"nii\":\n            mat = self._volume.header.get_base_affine()\n        else:\n            mat = self._volume.header.get_vox2ras_tkr()\n        m = Mat44(mat, space_from=\"voxel\", space_to=\"ras_tkr\")\n        m.extra['source_format'] = self._format\n        return m\n    def get_fdata(self):\n        return self._volume.get_fdata()\n    def _get_filepath(self, alternative_path : str = None, normalize : bool = True) -&gt; str:\n        path = self._volume.extra.get('file_path_original', None)\n        if path is None and alternative_path is not None:\n            path = os.path.abspath(alternative_path)\n            self._volume.to_filename(path)\n            self._volume.extra['file_path_original'] = path\n        if normalize:\n            path = os.path.abspath(path)\n        return path\n    def as_cache(self):\n        path = self._volume.extra.get('file_path_original', None)\n        if path is None:\n            if self._format == \"nii\":\n                suffix = \".nii.gz\"\n            else:\n                suffix = \".mgz\"\n            tfile = temporary_file(suffix = suffix, prefix = \"volume_\", delete = False)\n            tfile.close()\n            path = tfile.name\n        path = self._get_filepath(alternative_path = path, normalize = False)\n        return {\n            'path': path,\n            'absolute_path': os.path.abspath(path),\n            'file_name': os.path.basename(path),\n            'is_new_cache': False,\n            'is_cache': True,\n            'is_nifti': self._format == \"nii\",\n        }\n</code></pre>"},{"location":"api-utils/#threebrainpy.utils.VolumeWrapper.__init__","title":"<code>__init__(volume, **kwargs)</code>","text":"<p>Create a volume wrapper. The volume must be either NIFTI or FreeSurfer (mgh/mgz) format. @param volume: The volume to be wrapped. It can be either a file path or one of the followings:     1. nibabel.Nifti1Image     2. nibabel.Nifti2Image     3. nibabel.MGHImage</p> Source code in <code>threebrainpy/utils/volume.py</code> <pre><code>def __init__(self, volume, **kwargs) -&gt; None:\n'''\n    Create a volume wrapper. The volume must be either NIFTI or FreeSurfer (mgh/mgz) format.\n    @param volume: The volume to be wrapped. It can be either a file path or one of the followings:\n        1. nibabel.Nifti1Image\n        2. nibabel.Nifti2Image\n        3. nibabel.MGHImage\n    '''\n    if isinstance(volume, str):\n        volume = read_volume(volume, **kwargs)\n    self._volume = volume\n    # make sure the volume is in the correct format\n    if isinstance(volume, (nibabel.Nifti1Image, nibabel.Nifti2Image)):\n        self._format = \"nii\"\n    elif isinstance(volume, (nibabel.MGHImage)):\n        self._format = \"mgz\"\n    else:\n        raise ValueError(f\"Unsupported volume type: {type(volume)}. Please make sure this is a valid NIFTI or FreeSurfer volume.\")\n    pass\n</code></pre>"},{"location":"api-utils/#threebrainpy.utils.read_xfm","title":"<code>read_xfm(path)</code>","text":"<p>Read a FreeSurfer talairach.xfm file and return a dict with keys: @param path: The path to the talairach.xfm file. @return: A dict with keys:     'path': The absolute path to the talairach.xfm file.     'transform': The transform matrix.     'transform_type': The type of the transform. Always 'Linear' (Non-linear transforms are not supported yet).</p> Source code in <code>threebrainpy/utils/readxfm.py</code> <pre><code>def read_xfm(path):\n'''\n    Read a FreeSurfer talairach.xfm file and return a dict with keys:\n    @param path: The path to the talairach.xfm file.\n    @return: A dict with keys:\n        'path': The absolute path to the talairach.xfm file.\n        'transform': The transform matrix.\n        'transform_type': The type of the transform. Always 'Linear' (Non-linear transforms are not supported yet).\n    '''\n    # path = '/Users/dipterix/rave_data/raw_dir/PCC/rave-imaging/fs/mri/transforms/talairach.xfm'\n    if not os.path.exists(path):\n        raise FileNotFoundError(f\"File {path} not found.\")\n    with open(path, \"r\") as f:\n        s = f.readlines()\n    m = [re.match(xfm_regexp, x).groups() for x in s if re.match(xfm_regexp, x) is not None]\n    mat = Mat44(m, space_from=\"ras\", space_to=\"mni305\")\n    return {\n        'path': os.path.abspath(path),\n        'transform': mat,\n        'transform_type': 'Linear',\n    }\n</code></pre>"}]}